// TSS Library Script

// TRUE SCI-Fi STATS (TSS) SCRIPT by Aassmodeuss

// Credits
  // Yi1i1i - For creating True AUto Stats (TSS) which this entire script is based on
  // BinKompliziert - Idea for Capitalization weighting for skill learning
  // jackoneill2443 - Idea for modifying player input to show stat results
  // LewdLeah - General Scripting Knowledge
//

// This function runs the library hook
onLibrary_TSS();

// LIBRARY HOOK
function onLibrary_TSS() {
  // UNLOCK SCRIPT FOR DEBUG (Comment out to turn off)
  state.startScript = true;
  log("state.startScript: " + state.startScript);

  // Initialize variables
  if (state.startScript == undefined) {
    state.startScript = false;
  }
  if (state.turnCount == undefined) {
    state.turnCount = 0;
  }
  if (state.msgHolder == undefined){
    state.msgHolder = "";
  }
}

// Utility function to get weapon names from story cards
function getWeaponNamesFromStoryCards() {
    return storyCards
        .filter(sc => sc.type === "Weapons" || sc.category === "Weapons") // adjust as needed
        .map(sc => sc.title.toLowerCase());
}

// INPUT HOOK
function onInput_TSS(text) {
  
  //Check for unlocking
  text = unlockScript(text);

  //Check for locking
  text = lockScript(text);

  helpCommandInput_TSS(text);

  //Unlocking runs main()
  if (state.startScript == true && info.actionCount >= 0) {
    state.inputCount += 1;
    log("state.inputCount: " + state.inputCount);

    //Check for skill instructions
 state.skillInstructionShown = false; 

    // Always check for game over due to corruption at the start of every turn
  if (state.gameOver) {
  let gameOverMsg = " The corruption of the warp overwhelms you. You are possessed by an entity of the warp and lose control of your body. GAME OVER.\n";
  text += gameOverMsg;
  state.msgHolder += "GAME OVER. You were possessed by corruption!\n";
  return text;
}

    //Detect weapon equip/holster first
    text = detectWeaponEquip(text);

     //Detect fire mode toggles (standalone)
    text = detectFireModeToggle(text);


    //Create story cards if none
    createIfNoStatSC();
    createIfNoInvSC();
    createIfNoSkillSC();
    createIfNoPsykerSpellSC();
    createIfNoModifierSC();        
    createIfNoWeaponSC();    
    createIfNoWeaponmodSC();
    createIfNoEquippedWeaponSC();
    createIfNoInjurySC();
  
    //Updates codebase if player edits their storage SCs
    retrieveStatsFromSC();
    retrieveSkillsFromSC();
    retrievePsykerSpellsFromSC();
    retrieveInvFromSC();
    retrieveModifiersFromSC();
    retrieveWeaponFromSC();
    retrieveWeaponmodsFromSC();
    retrieveEquippedWeaponFromSC();
    

    text = detectPassiveSkillTrigger(text);

    text = detectStoreInv(text);

    text = detectRemoveFromInv(text);

    text = detectAttack(text);
    
    text = detectRangedattack(text);

    text = detectPlrActionsCallingStorage(text);

    text = detectResting(text);

    text = detectConsuming(text);

    text = upgradePlayerSkills(text);

    text = warnPlayerHealth(text);

    text = detectReload(text);

 
   }//end of main()
  

  return text;
}

// CONTEXT HOOK
function onContext_TSS(text){
  log("onContext_TSS: state.skillInstructionShown = " + state.skillInstructionShown);
  text = removeAngleText(text);
  text = removeAngleText(text);

  // Inject skill instruction if needed
  if (state.skillInstructionShown) {
    text = "<SYSTEM> # Player Skills are rated from level 1 to 100. Level 1 is a novice, level 100 is an expert. Determine the action's difficulty based on the context of the story and the player character's skill level. Skill attempts can fail, succeed, or partially succeed.</SYSTEM>\n" + text;
    text = injectStoryCardToContext("Player Skills", text);
    log("state.skillInstructionShown: " + state.skillInstructionShown);
  }

  // Inject equipped weapon instruction
  text = injectEquippedWeaponInstruction(text);

  return text;
}

// OUTPUT HOOK
function onOutput_TSS(text) {
  text = helpCommandOutput_TSS(text);

  // start of main()
  if (state.startScript == true && info.actionCount >= 0) {
    state.outputCount += 1;
    log("state.outputCount: " + state.outputCount);

    //Create story cards if none
    createIfNoStatSC();
    createIfNoInvSC();
    createIfNoSkillSC();
    createIfNoPsykerSpellSC();
    createIfNoModifierSC();
    createIfNoWeaponSC();
    createIfNoWeaponmodSC();
    createIfNoEquippedWeaponSC();
    createIfNoInjurySC();

   if (state.gameOver) {
  let gameOverMsg = " #The corruption of the warp overwhelms you. You are possessed by an entity of the warp and lose control of your body. GAME OVER. #\n";
  text += gameOverMsg;
  state.msgHolder += "GAME OVER. You were possessed by corruption!\n";
  return text;
}


    //Updates player stats in code if player edits their stats in SC
    retrieveStatsFromSC();
    //Stat edits made by the code
    playerNaturalRegen();
    text = detectHurt(text);
    //Final stats store back to SC in correct formatting
    storeStatsToSC();


    //Updates player skills in code if player edits their skills in SC
    retrieveSkillsFromSC();
    //Final skill store back to SC in correct formatting
    storeSkillsToSC();
   
    //Updates psyker spells in code if player edits their spells in SC
    retrievePsykerSpellsFromSC();
    //Final spell store back to SC in correct formatting
    storePsykerSpellsToSC();

    //Updates player inv in code if player edits their inv in SC
    retrieveInvFromSC();
    //Final skill store back to SC in correct formatting
    storeInvToSC();

    //Updates player mods in code if player edits their mods in SC
    retrieveModifiersFromSC();
    //Final mods store back to SC in correct formatting
    storeModifiersToSC();
    
    //Updates Weapon in code if player edits Weapon in SC
    retrieveWeaponFromSC();
    //Final stats store back to SC in correct formatting
    storeWeaponToSC();
    
    //Updates weapon mods in code if player edits their weapon mods in SC
    retrieveWeaponmodsFromSC();
    //Final mods store back to SC in correct formatting
    storeWeaponmodsToSC();

   // Retrieve equipped weapon from the "Equipped Gear" category
   //retrieveEquippedWeaponFromSC()
   //Final equipped weapon stores back to SC in correct formatting
   //storeEquippedWeaponToSC()

    state.message = state.msgHolder;
    state.msgHolder = "";

    turnCounter();
  }//end of main()
  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

// Matches "you", "your", "yourself", "yours", "i", "my", "mine", "myself" (case-insensitive)
const youWordsRegex = /\b(you|your|yourself|yours|i|my|mine|myself)\b/i;

//Non inventory item blacklist words.
const nonItemRegex = /\b(cover( behind)?|in cover|take cover|shelters?|barriers?|corners?|walls?|floors?|grounds?|ceilings?|windows?|doors?|hallways?|corridors?|rooms?|crates?|tables?|chairs?|beds?|barricades?|pillars?|platforms?|ledges?|alcoves?|nooks?|hides?|hiding spots?|spots?|locations?|areas?|places?|positions?|stances?( behind| in| at)?|take aim|aim|surroundings?)\b/i;

selfWords = ["me", "my", "myself", "mine", "your", "yourself", "yours", "us", "our", "ours", "ourselves"
];

castWords = [
  "activate", "amplify", "bind", "blast", "boost", "burst", "cast", "casting", "channel", "charge", "channeling", "command", "commanding", "conjure", 
  "create", "creating", "detonate", "enchant", "enchanting", "evoke", "explode", 
  "expel", "exude", "flare", "flow", "form", "gather", "gathering", "glow", "harness", "hex", "ignite", "infuse", "invoke", "invoking", "launch", "manifest", "project", "projecting", "pulse","perform", "quicken", "release", "shape", "shift", "shoot", "shooting", "summon", "summoning", "transform", "transforming", "transmute", "trigger", "unbind", "unleash"
];

equipWords = [
  "acquire", "add", "collect", "equip", "gather", "grab", "hold", "keep", "loot", "obtain", "pick", "put", "receive", "retrieve", "stash", "snatch", "store", "take", "toss", "wear"
];

invWords = [
  "bag", "backpack", "body", "case", "chest", "collection",  "container", "crates", "equipment", "hands", "hand", "holder", "holdings", "holster", "inventory", "items", "legs", "loot", "pack", "pocket", "pouch", "rucksack", "sack", "satchel", "storage", "supplies", "tote"
];

numWords = [
  "0", "1", "2", "3", "4", "5", "6", "7", "8", "9",
  "zero", "one", "two", "three", "four", "five", "six", "seven", "eight", "nine",
  "ten", "eleven", "twelve", "thirteen", "fourteen", "fifteen", "sixteen", "seventeen", "eighteen", "nineteen",
  "twenty", "thirty", "forty", "fifty", "sixty", "seventy", "eighty", "ninety",
  "hundred", "thousand", "million", "billion", "trillion"
];

titleWords = ["mr", "mrs", "ms", "dr", "prof", "captain", "sir", "lady", "officer", "detective", "colonel", "general", "lieutenant", "president", "governor", "mayor", "minister","ambassador", "director", "agent", "coach", "principal", "judge", "dean", "sister","brother", "father", "mother", "daughter", "son", "king", "queen", "prince", "princess","professor"];

stopWords = [
  // Pronouns
  "I", "me", "my", "myself", "we", "our", "ours", "ourselves",
  "you", "your", "yours", "yourself", "yourselves",
  "he", "him", "his", "himself", "she", "her", "hers", "herself",
  "it", "its", "itself", "they", "them", "their", "theirs", "themselves",

  // Question Words
  "what", "which", "who", "whom", "whose", "when", "where", "why", "how",

  // Auxiliary & Modal Verbs
  "am", "is", "are", "was", "were", "be", "been", "being",
  "have", "has", "had", "having",
  "do", "does", "did", "doing",
  "can", "could", "will", "would", "shall", "should", "must", "might", "may",

  // Negatives
  "not", "no", "nor", "never", "none", "nothing", "nowhere", "neither",
  "isn't", "aren't", "wasn't", "weren't", "hasn't", "haven't", "hadn't",
  "doesn't", "don't", "didn't", "won't", "wouldn't", "shan't", "shouldn't",
  "can't", "cannot", "couldn't", "mightn't", "mustn't", "needn't",

  // Conjunctions & Prepositions
  "and", "but", "or", "because", "as", "until", "while",
  "of", "at", "by", "for", "with", "about", "against",
  "between", "into", "through", "during", "before", "after",
  "above", "below", "to", "from", "up", "down", "in", "out",
  "on", "off", "over", "under", "onto", "upon", "around",

  // Articles & Determiners
  "a", "an", "the", "this", "that", "these", "those",
  "some", "any", "each", "every", "either", "neither",
  "such", "own", "other", "another", "both", "all", "several", "many", "most", "few", "since",

  // Time-Related Words
  "again", "further", "then", "once", "already", "soon", "later", "finally", "next",

  // Place Words
  "here", "there", "everywhere", "somewhere", "anywhere", "nowhere",

  // Degree & Quantifier Words
  "very", "too", "just", "only", "more", "less", "than", "enough", "almost",
  "rather", "quite", "really", "such",

  // Common Verbs & Adverbs
  "try", "trying", "tries", "take", "takes", "taking",
  "look", "looks", "looking",
  "seem", "seems", "seemed", "appears", "appeared",
  "go", "goes", "going", "gone",
  "come", "comes", "coming",
  "get", "gets", "getting", "got", "gotten",
  "make", "makes", "making", "made",
  "say", "says", "saying", "said", "heard",
  "know", "knows", "knew", "stopping", "stops", "becomes",

  // Game-Specific Terms
  "skill", "ability", "executes", "existing",
  "increases corruption", "consumes energy", "successfully",
  "suddenly", "predictably", "efficiently", "cast"
];

healingActions = [
  "heal", "recover", "restore", "regenerate", "revitalize", 
  "rejuvenate", "mend", "bandage", "apply", "inject", "swallow", "absorb", "patch", "treat", "stitch","splint"
];

consumeWords = [
  "drink", "eat", "consume", "inject", "swallow", "absorb", "devour", "ingest", "chew", "bite", "sip", "gulp"
];

// Light healing items (basic healing items)
lightHealWords = [
  "bandage", "herb", "potion", "water", "minor","salve","ointment","icepack","rinse","snack", "cooked","cook","cooking"
];

// Moderate healing items (more effective healing items)
moderateHealWords = ["healing", "elixir", "tincture", "small", "bandage","magic","oil","food","meal","breakfast","lunch","dinner","delicious"
];

// Strong healing items (stronger healing items for larger wounds)
strongHealWords = ["large", "larger", "strong", "big", "scroll", "balm", "alcohol", "cream"
];

// Intense healing items (used for serious injuries or magical healing)
greatHealWords = ["superior", "life elixir", "antibacterial", "vitality", "greater","great","rare"
];

// Powerful healing items (used for critical injuries or to restore near full health)
powerfulHealWords = ["immortality", "crystal", "revival", "divine", "surgery","enchanted","powerful","extremely","extreme","mystical","legendary"
];

enterWords = ["crawl", "drift", "enter", "fall", "get", "go", "head", "lay", "lie down", "make", "move", "nap", "prepare", "proceed", "slip", "sleep", "settle", "sink", "snuggle", "step", "surrender", "take", "turn in", "transition"];

restingWords = ["catnap", "doze", "hibernate", "nap", "relax", "rest", "sleep", "slumber", "asleep"];

lightRestWords = ["brief", "fleeting", "minor", "momentary", "passing", "quick", "relax", "short", "small", "tiny", "transient", "breath", "breathe", "breathing"];

moderateRestWords = ["catnap", "doze", "light sleep", "nap", "power nap", "repose", "rest", "siesta", "snooze", "rest"];

fullRestWords = ["deep", "deeply", "hibernation", "hibernate", "long", "prolonged", "rejuvenating", "sleep", "slumber", "sound", "uninterrupted"];

dialoguePhrases = ["You say", "You tell", "You add", "You ask", "You reply", "You state", "You note", "You claim", "You remark", "You mutter", "You insist", "You whisper", "You mention", "You declare", "You respond", "You warn", "You said", "You see", "You hear"];

realizePhrases = ["It becomes apparent", "It becomes clear that", "It clicks that", "You start to realize", "You come to realize", "You come to understand", "You feel that", "You grasp the fact that", "You notice", "You realize", "You recognize that", "You see that", "It dawns on you that"];

becauseYouPhrases = ["because you", "since you", "as you", "given that you", "considering that you", "owing that you", "on account that you", "by virtue that you", "seeing as you", "thanks that you", "as a result that you", "in light that you", "for the reason that you", "in view that you", "due to the fact that you"
];

assumedWrongPhrases = ["assumed competence", "assumed preparation", "assumed you had on hand what you didn't", "didn't harness existent skills", "didn't harness existent talents", "didn't specify proficiency", "didn't specify reasonably", "expected the air to do something", "failed to secure necessary resources", "forgot to bring the right tools", "had a moment of inexperience", "missed key details", "neglected to prepare properly", "neglected proper planning", "overestimated your readiness", "rushed past your experience", "skipped on clarity", "skipped the resource", "underestimated the necessities", "underprepared", "weren't thorough enough", "were ill-equipped", "were not clear", "were too hasty"];


slightlyWorseResults = ["the outcome was close, but mostly off the mark", "the outcome was mostly underwhelming", "the outcome was less than ideal", "the outcome was disappointing", "the outcome was not as good as anticipated", "the result didn't quite measure up", "the result fell short of expectations", "the result was below the expected level", "the result was not quite what was hoped for", "the performance didn't meet expectations", "the performance was below expectations", "the performance was shy of expectations", "the performance was quite subpar", "the final outcome was mildly disappointing", "the final result was a bit of a letdown"];

attackWords = ["attack", "ambush", "bash", "batter", "bite", "bludgeon", "chop", "claw", "cleave", "club", "crush", "flail", "gouge", "impale", "jab", "kick", "lunge", "maul", "pound", "pummel", "pierce", "punch", "ram", "rend", "shred", "slash", "slam", "slice", "smash", "stab", "strike", "swipe", "swing", "smack", "thrust", "whack", "wreck"];

rangedattackWords = ["fire","loose", "launch", "shoot"];

// Injury detection regex arrays
const severeHurtWords = [
  /severely wounded/i, /critically injured/i, /bleeding out/i, /mortal wound/i, /fatal blow/i, /limb.*severed/i, /skull.*fractured/i
];
const greatHurtWords = [
  /badly wounded/i, /broken bone/i, /deep gash/i, /major burn/i, /compound fracture/i, /heavy bleeding/i, /bullet wound/i, /las burn/i 
];
const strongHurtWords = [
  /badly hurt/i, /sprained/i, /dislocated/i, /stab wound/i, /bad burn/i, /heavy bruise/i
];
  const moderateHurtWords = [
  /wounded/i, /cut/i, /gash/i, /burn/i, /bruised/i, /swollen/i, /bleeding/i
];
const lightHurtWords = [
  /scraped/i, /scratched/i, /minor cut/i, /small bruise/i, /bumped/i, /nicked/i, /lightly wounded/i
];

const skillTriggerMap = {
  // Tech skills
  "debug": ["debug", "diagnose", "troubleshoot"],
  "hack": ["hack", "bypass", "override", "crack", "breach"],
  "defragment": ["defragment", "optimize"],
  "reboot": ["reboot", "restart", "reset"],
  "program": ["code", "program", "reprogram", "script"],
  "encrypt": ["encrypt", "secure"],
  "decrypt": ["decrypt", "decode", "unscramble"],
  "scan": ["diagnostic", "scan", "analyze"],
  

  // Engineer skills
  "repair": ["repair", "fix", "mend", "patch", "refurbish", "restore", "rebuild", "reconstruct"],
  "calibrate": ["calibrate", "tune", "adjust"],
  "maintain": ["maintain", "service"],
  "upgrade": ["upgrade", "improve", "enhance"],
  "disassemble": ["disassemble", "take apart", "dismantle", "deconstruct", "break down"],
  "build": ["build", "erect", "construct", "assemble", "put together", "fabricate"],
  "refit": ["refit", "retrofit", "retool", "adapt", "modify", "alter", "reconfigure"],
  // Add more as needed
};

const attackTier1 = [
  "A hesitant impact leaves a soft but clear mark.",
  "A clumsy strike stirs the air noticeably.",
  "The blow lands with a hint of effect.",
  "A weak connection is made, just enough to be felt.",
  "The strike glances off, carrying some force.",
  "A light tap echoes with a gentle thud.",
  "A slight poke leaves a subtle but real impression.",
  "The hit brushes past, leaving a small trace.",
  "A hopeful flail finds its mark with modest impact.",
  "The effort shows, with a bit more strength than before.",
  "The movement is quick but still leaves a clear trace.",
  "A faint energy pulses from the impact point.",
  "The jab lingers briefly, not fading so fast.",
  "The warning registers, causing slight unease.",
  "A flicker of contact draws a small reaction.",
  "The strike carries more weight, hinting at threat.",
  "A hesitant impact barely registers.",
  "A clumsy strike barely disturbs the air.",
  "The blow lands with uncertain effect.",
  "A weak connection is made, barely felt.",
  "The strike glances off without much force.",
  "A light tap echoes faintly.",
  "A slight poke leaves a minor impression.",
  "The hit brushes past with little consequence.",
  "A hopeful flail reaches its mark, barely.",
  "The effort is noticeable but lacks strength.",
  "The movement is rushed, leaving a faint trace.",
  "An energy sighs away from the impact point.",
  "The jab seems unsure, fading quickly.",
  "A minor tremble follows the effort.",
  "The strike is more suggestion than threat.",
  "An unsteady hit makes barely a difference."
];

const attackTier2 = [
  "A decent impact settles on the target.",
  "A steady thud marks the connection.",
  "The strike finds its place without fuss.",
  "The hit pushes slightly against the defense.",
  "A clean contact echoes calmly.",
  "The jab lands with clear but modest effect.",
  "The impact is steady, leaving a small dent.",
  "The blow connects and holds its ground.",
  "A practiced move leaves a noticeable mark.",
  "The force carries a measured weight.",
  "The strike resonates with steady rhythm.",
  "A slight shift follows the connection.",
  "The weapon's touch is firm but not harsh.",
  "A forward push accompanies the hit.",
  "A quiet grunt follows the impact.",
  "The movement holds just enough power.",
  "The warning slightly registers with the target.",
  "A flicker of contact is acknowledged.",
  "The strike carries more intention than threat.",
  "The hit lands but lacks full follow-through.",
  "A mild force nudges the opponent.",
  "Contact is made, but leaves little impression."
];

const attackTier3 = [
  "A confident strike unsettles the target.",
  "The blow cuts through with purpose.",
  "A sharp impact causes a momentary stagger.",
  "The hit lands cleanly and with intent.",
  "A practiced motion sends ripples through the defense.",
  "Swift contact disrupts the opponent's stance.",
  "The blow presses through with steady force.",
  "Momentum drives the impact deeper.",
  "The movement feels well-rehearsed and sure.",
  "The strike resonates like a controlled pulse.",
  "Adjustments mid-motion still deliver the blow.",
  "The hit causes the target to hesitate.",
  "A message is conveyed through the impact.",
  "The rhythm of the strike flows naturally.",
  "The strike hints at growing skill.",
  "Precision underlies the connection.",
  "The effort is steady, if not sharp.",
  "A push more than a strike, but effective.",
  "Contact is solid, though not overwhelming."
];

const attackTier4 = [
  "A firm impact leaves a visible mark.",
  "The strike breaks through the guard.",
  "The target reels from the force.",
  "Momentum flows like water into steel.",
  "A heavy thud echoes with weight.",
  "The blow cuts a clean arc through defense.",
  "The hit lands fully on a weak point.",
  "The momentum drives the strike home.",
  "The stance holds firm beneath the impact.",
  "The strike lands with quiet certainty.",
  "A jolt runs through the opponent's posture.",
  "The blow locks into its intended angle.",
  "The hit ends any further resistance.",
  "Respect is earned with that connection.",
  "Control is evident in the impact.",
  "The strike carries the weight of experience.",
  "The motion is not flawless, but firm.",
  "A noticeable hit, though less than perfect.",
  "The force strikes true but lacks flourish."
];

const attackTier5 = [
  "The blow drives the target back noticeably.",
  "Force behind the hit disrupts balance.",
  "The air shifts sharply with the impact.",
  "Focused strength punishes the defense.",
  "The swing finds an opening wide enough to exploit.",
  "The sound of impact warns nearby foes.",
  "A disciplined strike lands with solid force.",
  "Momentum disrupts the opponent's rhythm.",
  "Hesitation breaks under the weight of the hit.",
  "The strike cuts through doubt and hesitation.",
  "Movement flows like water through resistance.",
  "The impact carries practiced momentum.",
  "The target lurches in response.",
  "The blow speaks of determination and strength.",
  "The hit unsettles with quiet authority.",
  "The connection leaves no room for recovery.",
  "The swing is effective, if not clean.",
  "Pressure builds behind the hit, just enough.",
  "Strength surges, though briefly delayed."
];

const attackTier6 = [
  "A forceful blow lands with sharp clarity.",
  "Resistance is sliced cleanly away.",
  "The motion flashes with practiced precision.",
  "The target is knocked back with graceful power.",
  "The strike lands like a measured command.",
  "Momentum flows with disciplined grace.",
  "The hit hums with controlled violence.",
  "A clean impact sends a ripple through the target.",
  "The movement cuts through defenses smoothly.",
  "Even gravity seems to respect the strike.",
  "The opponent braces, but the hit connects.",
  "A gasp escapes those watching the impact.",
  "The weapon's motion carries unyielding intent.",
  "The blow lands like a falling star’s certainty.",
  "The strike leaves a lasting impression.",
  "Momentum and precision unite in the hit.",
  "The delivery wavers slightly, but recovers.",
  "Control dips, yet the hit lands well.",
  "A moment's imbalance doesn't stop the strike."
];

const attackTier7 = [
  "Precision and power combine in the strike.",
  "Momentum fuels a decisive impact.",
  "The guard shudders under a sharp cut.",
  "A rhythmic force pulses through the blow.",
  "The hit arrives like the first drop of a storm.",
  "The enemy stumbles back in surprise.",
  "The weapon moves as if guided by instinct.",
  "Motion and violence merge seamlessly.",
  "The strike lands just ahead of expectation.",
  "The attack flows like a dancer’s movement.",
  "The air vibrates with the blow’s precision.",
  "Time seems to pause briefly at impact.",
  "Breath catches before the force lands.",
  "The connection speaks of practiced skill.",
  "The strike lands as if anticipated.",
  "Art and pain intertwine in the hit.",
  "One step falters, but the hit stays true.",
  "Sharp, but not quite flawless.",
  "Timing slips slightly, yet power holds."
];

const attackTier8 = [
  "The strike arrives almost unseen.",
  "The motion feels part of a larger force.",
  "Focused chaos drives the impact.",
  "The target barely perceives the blow.",
  "The hit rings out across the battlefield.",
  "Time itself seems to slow around the strike.",
  "Stance collapses beneath crashing force.",
  "The attack lands with quiet inevitability.",
  "Sound trails behind the motion.",
  "Movement weaves between magic and steel.",
  "The hit flows like a living gust.",
  "Shadows linger after the strike.",
  "Air warps where the blow lands.",
  "Presence alone seems to deliver the hit.",
  "A glint of light precedes impact.",
  "Pain wraps itself around the connection.",
  "The blur fades slightly before impact.",
  "Precision stutters but the strike connects.",
  "A pulse of force overcomes a shaky start."
];

const attackTier9 = [
 "The strike becomes a force of pure intent.",
  "The air parts before the hit.",
  "Expectations shatter along with defense.",
  "The blow thunders with deadly direction.",
  "Motion adjusts without losing force.",
  "Defense collapses under sheer will.",
  "Sound trails behind the impact.",
  "The target reacts too late to avoid it.",
  "A flash marks the turning point.",
  "The hit lands like fate fulfilled.",
  "Mastery speaks through the strike.",
  "Guard dissolves into suggestion.",
  "Recovery is denied by the blow.",
  "The world narrows to the weapon’s path.",
  "Space itself seems torn apart.",
  "The strike is a final verdict.",
  "Power is held, though briefly misaligned.",
  "Speed falters for a breath, but recovers.",
  "The hit stumbles, then erupts with force."
];

const attackTier10 = [
  "The strike carries the full weight of your being.",
  "This blow could close a chapter.",
  "Reality flickers with the swing's speed.",
  "The hit cuts like a blade from legend.",
  "Every atom agrees on the force delivered.",
  "Air and enemy alike are displaced.",
  "Belief itself feels cleaved by the strike.",
  "Possibility crumbles beneath the blow.",
  "Stillness splits like a whispered verdict.",
  "The swing feels like an ending.",
  "Muscle and myth combine in the hit.",
  "Air recoils from the passage of force.",
  "This is no mere strike — it’s judgment.",
  "History is written in the motion.",
  "Silence reigns before, awe after.",
  "The battlefield feels smaller in its wake.",
  "A ripple of imperfection rides a perfect blow.",
  "The strike trembles — then erupts.",
  "A final moment of doubt precedes a storm."
];

const rangedattackTier1 = [
  // 6 full misses (~30%)
  "The shot flies wide and misses the target.",
  "Your projectile lands far from where you aimed.",
  "The round goes off course and misses completely.",
  "The shot veers away, missing the mark.",
  "Your aim is off and the shot doesn't connect.",
  "The shot sails past, missing entirely.",
  // 5 near misses (~25%)
  "The shot passes close but doesn't quite hit.",
  "Your projectile grazes past the target.",
  "The round lands just beside the mark.",
  "The shot skims by, nearly making contact.",
  "Your aim is close, but the shot falls short.",
  // 7 imperfect hits (~35%)
  "The shot clips the edge of the target.",
  "Your projectile lands with a glancing hit.",
  "The round strikes the target, but not squarely.",
  "The shot lands low on the target.",
  "The projectile hits, though not where intended.",
  "The shot lands off-center on the target.",
  "Your round strikes the target, but only just.",
  // 2 direct hits (~10%)
  "The shot connects, but not with full force.",
  "The shot lands squarely on the target."
];

const rangedattackTier2 = [
  // 5 full misses (~25%)
  "The shot misses, landing just beyond the target.",
  "Your projectile goes wide, missing the mark.",
  "The round lands off to the side.",
  "The shot veers just outside the target.",
  "The shot flies past, missing entirely.",
  // 4 near misses (~20%)
  "The shot passes close, nearly hitting.",
  "Your projectile grazes the edge of the target.",
  "The round lands just short of the mark.",
  "The shot skims by, almost making contact.",
  // 8 imperfect hits (~40%)
  "The shot lands with a glancing blow.",
  "Your projectile strikes the target's edge.",
  "The round connects, but not cleanly.",
  "The shot lands low, but still hits.",
  "The projectile finds the target, though not perfectly.",
  "The shot lands off-center, but connects.",
  "Your round strikes the target, if only partially.",
  "The shot connects, though not with precision.",
  // 3 direct hits (~15%)
  "The projectile lands with a solid, if imperfect, hit.",
  "The round lands directly on the target.",
  "Your shot finds the center of the target."
];

const rangedattackTier3 = [
  // 4 full misses (~20%)
  "The shot misses, landing just past the target.",
  "Your projectile goes slightly wide.",
  "The round lands just outside the mark.",
  "The shot veers just off the target.",
  // 4 near misses (~20%)
  "The shot passes close, nearly making contact.",
  "Your projectile grazes the target's edge.",
  "The round lands just beside the mark.",
  "The shot skims by, almost making contact.",
  // 8 imperfect hits (~40%)
  "The shot lands with a clear, if off-center, hit.",
  "Your projectile strikes the target, though not squarely.",
  "The round connects, but not with full force.",
  "The shot lands low, but still finds the target.",
  "The projectile finds the target, though not perfectly.",
  "The shot lands off-center, but makes contact.",
  "Your round strikes the target, if only partially.",
  "The shot connects, though not with precision.",
  // 4 direct hits (~20%)
  "The projectile lands with a solid, if imperfect, hit.",
  "The round lands directly on the target.",
  "Your shot finds the center of the target.",
  "The projectile strikes the target cleanly."
];

const rangedattackTier4 = [
  // 3 full misses (~15%)
  "The shot misses, landing just past the target.",
  "Your projectile goes just wide of the mark.",
  "The round lands just outside the target.",
  // 3 near misses (~15%)
  "The shot passes close, nearly making contact.",
  "Your projectile grazes the target's edge.",
  "The round lands just beside the mark.",
  // 9 imperfect hits (~45%)
  "The shot lands with a clear, if off-center, hit.",
  "Your projectile strikes the target, though not squarely.",
  "The round connects, but not with full force.",
  "The shot lands low, but still finds the target.",
  "The projectile finds the target, though not perfectly.",
  "The shot lands off-center, but makes contact.",
  "Your round strikes the target, if only partially.",
  "The shot connects, though not with precision.",
  "The projectile lands with a solid, if imperfect, hit.",
  // 5 direct hits (~25%)
  "The round lands directly on the target.",
  "Your shot finds the center of the target.",
  "The projectile strikes the target cleanly.",
  "The shot lands right where you aimed.",
  "The projectile lands squarely on the mark."
];

const rangedattackTier5 = [
  // 2 full misses (~10%)
  "The shot misses, landing just past the target.",
  "Your projectile goes just wide of the mark.",
  // 3 near misses (~15%)
  "Your projectile grazes the target's edge.",
  "The round lands just beside the mark.",
  "The shot skims by, almost making contact.",
  // 8 imperfect hits (~40%)
  "The shot lands with a clear, if off-center, hit.",
  "Your projectile strikes the target, though not squarely.",
  "The round connects, but not with full force.",
  "The shot lands low, but still finds the target.",
  "The projectile finds the target, though not perfectly.",
  "The shot lands off-center, but makes contact.",
  "Your round strikes the target, if only partially.",
  "The shot connects, though not with precision.",
  // 7 direct hits (~35%)
  "The shot connects with a solid impact.",
  "The projectile lands with a confident hit.",
  "The shot lands with a clear, solid impact.",
  "The round lands directly on the target.",
  "Your shot finds the center of the target.",
  "The projectile strikes the target cleanly.",
  "The shot lands right where you aimed."
];

const rangedattackTier6 = [
  // 1 full miss (~5%)
  "The shot misses, landing just past the target.",
  // 2 near misses (~10%)
  "Your projectile grazes the target's edge.",
  "The round lands just beside the mark.",
  // 7 imperfect hits (~35%)
  "The shot lands with a clear, if off-center, hit.",
  "Your projectile strikes the target, though not squarely.",
  "The round connects, but not with full force.",
  "The shot lands low, but still finds the target.",
  "The projectile finds the target, though not perfectly.",
  "The shot lands off-center, but makes contact.",
  "Your round strikes the target, if only partially.",
  // 10 direct hits (~50%)
  "The shot connects with a solid impact.",
  "The projectile lands with a confident hit.",
  "The shot lands with a clear, solid impact.",
  "The round lands directly on the target.",
  "Your shot finds the center of the target.",
  "The projectile strikes the target cleanly.",
  "The shot lands right where you aimed.",
  "Your round hits the target with confidence.",
  "The projectile lands squarely on the mark.",
  "The shot finds its mark with certainty."
];

const rangedattackTier7 = [
  // 1 full miss (~5%)
  "The shot misses, landing just past the target.",
  // 1 near miss (~5%)
  "Your projectile grazes the target's edge.",
  // 6 imperfect hits (~30%)
  "The shot lands with a clear, if off-center, hit.",
  "Your projectile strikes the target, though not squarely.",
  "The round connects, but not with full force.",
  "The shot lands low, but still finds the target.",
  "The projectile finds the target, though not perfectly.",
  "The shot lands off-center, but makes contact.",
  // 12 direct hits (~60%)
  "The shot connects with a solid impact.",
  "The projectile lands with a confident hit.",
  "The shot lands with a clear, solid impact.",
  "The round lands directly on the target.",
  "Your shot finds the center of the target.",
  "The projectile strikes the target cleanly.",
  "The shot lands right where you aimed.",
  "Your round hits the target with confidence.",
  "The projectile lands squarely on the mark.",
  "The shot finds its mark with certainty.",
  "The round lands exactly where intended.",
  "The shot lands with precision."
];

const rangedattackTier8 = [
  // 0 full misses
  // 1 near miss (~5%)
  "Your projectile grazes the target's edge.",
  // 5 imperfect hits (~25%)
  "The shot lands with a clear, if off-center, hit.",
  "Your projectile strikes the target, though not squarely.",
  "The round connects, but not with full force.",
  "The shot lands low, but still finds the target.",
  "The projectile finds the target, though not perfectly.",
  // 14 direct hits (~70%)
  "The shot connects with a solid impact.",
  "The projectile lands with a confident hit.",
  "The shot lands with a clear, solid impact.",
  "The round lands directly on the target.",
  "Your shot finds the center of the target.",
  "The projectile strikes the target cleanly.",
  "The shot lands right where you aimed.",
  "Your round hits the target with confidence.",
  "The projectile lands squarely on the mark.",
  "The shot finds its mark with certainty.",
  "The round lands exactly where intended.",
  "The shot lands with precision.",
  "The projectile strikes the center cleanly.",
  "The shot lands with unwavering accuracy.",
  "The round finds the exact spot you aimed for."
];

const rangedattackTier9 = [
  // 0 full misses
  // 0 near misses
  // 4 imperfect hits (~20%)
  "The shot lands with a clear, if off-center, hit.",
  "Your projectile strikes the target, though not squarely.",
  "The round connects, but not with full force.",
  "The shot lands low, but still finds the target.",
  // 16 direct hits (~80%)
  "Your aim is steady, and the shot connects.",
  "The projectile finds the target with certainty.",
  "The shot connects with a solid impact.",
  "The projectile lands with a confident hit.",
  "The shot lands with a clear, solid impact.",
  "The round lands directly on the target.",
  "Your shot finds the center of the target.",
  "The projectile strikes the target cleanly.",
  "The shot lands right where you aimed.",
  "Your round hits the target with confidence.",
  "The projectile lands squarely on the mark.",
  "The shot finds its mark with certainty.",
  "The round lands exactly where intended.",
  "The shot lands with precision.",
  "The projectile strikes the center cleanly.",
  "The shot lands with unwavering accuracy.",
  "The round finds the exact spot you aimed for.",
  "The shot lands perfectly on target."
];

const rangedattackTier10 = [
  // 0 full misses
  // 0 near misses
  // 0 imperfect hits
  // 20 direct hits (100%)
  "The shot lands perfectly on target.",
  "Your projectile strikes the center without deviation.",
  "The round lands exactly where intended.",
  "The shot finds its mark with certainty.",
  "The projectile lands squarely on the mark.",
  "Your round hits the target with confidence.",
  "The shot lands right where you aimed.",
  "The projectile strikes the target cleanly.",
  "Your shot finds the center of the target.",
  "The round lands directly on the target.",
  "The shot lands with unwavering accuracy.",
  "The projectile strikes the center cleanly.",
  "The shot lands with precision.",
  "The round finds the exact spot you aimed for.",
  "The shot connects with a solid impact.",
  "The projectile lands with a confident hit.",
  "The shot lands with a clear, solid impact.",
  "Your aim is steady, and the shot connects.",
  "The projectile finds the target with certainty.",
  "The shot lands with flawless accuracy."
];

const atkSpdTier1 = [
  "A hesitant shuffle barely stirs the air",
  "Your movement feels a bit sluggish",
  "A slow step carries little urgency",
  "A slow shuffle signals your move",
  "You move with gentle hesitation",
  "Your movement barely stirs the air",
  "A careful step precedes the strike",
  "The motion is tentative, almost cautious",
  "You move with measured calm",
  "Your approach is soft and unhurried",
  "A subtle adjustment hints at your intent",
  "Your action unfolds with quiet restraint",
  "The speed feels easy, almost lazy"
];

const atkSpdTier2 = [
  "Your step drags slightly behind your intent",
  "A mild hesitation delays your movement",
  "Your pace feels a touch uneven",
  "Your step quickens slightly",
  "A light breeze follows your motion",
  "You move with steady purpose",
  "A deliberate pace guides your action",
  "The flow is smooth but unassuming",
  "Your movement has quiet determination",
  "You prepare with a mild surge of energy",
  "The motion gains a bit of momentum",
  "You advance with modest speed",
  "Your actions become more assured"
];

const atkSpdTier3 = [
  "Your motion starts a bit slow but builds",
  "The first step lacks some confidence",
  "You move with cautious energy",
  "Your movement picks up pace",
  "The air shifts around your motion",
  "You flow with balanced energy",
  "A sharper rhythm marks your steps",
  "You move with clear intent",
  "Your speed adds weight to your presence",
  "The motion feels precise and ready",
  "You approach with a confident glide",
  "Your steps echo mild assurance",
  "The pace feels natural and focused"
];

const atkSpdTier4 = [
  "Your momentum hesitates for a moment",
  "Your pace is a touch uneven",
  "The motion lingers before picking up",
  "Your motion cuts through the air",
  "A brisk rhythm underlies your move",
  "You advance with crisp clarity",
  "The flow hums with growing energy",
  "Your steps land with noticeable speed",
  "Your movement sharpens, gains focus",
  "A quickened pulse marks your action",
  "You press forward with steady force",
  "Your motion brims with readiness",
  "You move with clear, controlled speed"
];

const atkSpdTier5 = [
  "Your movement carries a mild drag",
  "A slight wobble marks your step",
  "Your pace wavers before steadying",
  "Your speed commands attention",
  "The air ripples from your motion",
  "You move with crisp determination",
  "A vibrant energy fuels your pace",
  "Your steps fall with bold intent",
  "The motion is sharp and precise",
  "Your presence quickens markedly",
  "You push forward with clear momentum",
  "Your movement holds assured power",
  "The speed carries a steady edge"
];

const atkSpdTier6 = [
  "Your stride starts hesitant, then sharpens",
  "The pace momentarily slips before firming",
  "Your motion hesitates then flows",
  "Your motion flows like a sharp breeze",
  "You cut through space with grace",
  "Your steps ring with confident speed",
  "A focused energy drives your movement",
  "You advance with quick, measured force",
  "Your speed is keen and effective",
  "The flow carries purposeful rhythm",
  "You move like a sharpened blade",
  "Your pace is lively and exact",
  "Your motion is a clear signal of intent"
];

const atkSpdTier7 = [
  "Your burst slows slightly before surging",
  "A slight stumble before regaining speed",
  "The motion briefly falters but continues",
  "Your speed feels like a quick gust",
  "You strike the air with sharp precision",
  "Your movement blends speed and grace",
  "The motion crackles with kinetic energy",
  "You advance like a sudden breeze",
  "Your steps flash with clear intent",
  "Your flow carries dynamic force",
  "You push forward with swift confidence",
  "The pace hums with controlled power",
  "Your motion cuts cleanly through space"
];

const atkSpdTier8 = [
  "Your motion blurs, then slows briefly",
  "A flicker of hesitation passes",
  "The strike stutters before cutting through",
  "Your motion blurs briefly in the air",
  "A swift current follows your steps",
  "You move with lightning-quick focus",
  "The air buzzes at your approach",
  "You press forward with striking velocity",
  "Your movement slices sharply",
  "The rhythm of your steps commands space",
  "You glide forward with fierce intent",
  "Your speed hints at latent power",
  "Your motion is a sudden, clear force"
];

const atkSpdTier9 = [
  "Your quickness wavers just before impact",
  "A momentary slack in your pace",
  "The strike pauses briefly, then strikes true",
  "You flash forward with sharp precision",
  "The air parts sharply before you",
  "Your steps echo with rapid intent",
  "You move like a sudden gust of wind",
  "Your motion strikes with clear force",
  "The pace is fierce but controlled",
  "Your speed carries focused energy",
  "You push through space with crisp power",
  "The rhythm of your steps is electric",
  "Your movement demands attention"
];

const atkSpdTier10 = [
  "Your motion falters, then rockets forward",
  "A brief hesitation in the storm of your strike",
  "The speed ebbs, then surges with force",
  "Your motion is a streak of clarity",
  "You slice through space with perfect timing",
  "The air crackles as you move",
  "Your steps thunder with swift authority",
  "You strike with unstoppable speed",
  "Your movement is a force of nature",
  "You blur through the moment, precise and fierce",
  "The pace is relentless and exact",
  "Your speed commands the battlefield",
  "You move with the certainty of a storm"
];

const ratkSpdTier1 = [
  "Your aim is slow to settle",
  "You take a long moment to line up your shot",
  "Your targeting is sluggish and hesitant",
  "You fumble with your sights, losing precious time",
  "You’re slow to focus on your mark",
  "You struggle to steady your aim",
  "You’re late to react, your targeting delayed",
  "You hesitate before committing to the shot",
  "You’re distracted, your aim wandering",
  "You’re slow to track your target",
  "You’re caught off guard, your aim lagging",
  "You’re sluggish to adjust your sights",
  "You’re slow to find your mark",
  "You’re unsteady, your aim wavering",
  "You’re slow to bring your sights to bear",
  "You’re late to align your shot",
  "You’re slow to respond to movement",
  "You’re hesitant to take the shot",
  "You’re slow to react to the opportunity",
  "You’re delayed in lining up your attack"
];

const ratkSpdTier2 = [
  "You take your time to aim",
  "You’re careful, but not quick to target",
  "You move at a measured pace to line up your shot",
  "You’re deliberate in your targeting",
  "You’re steady, but your aim is not fast",
  "You’re cautious as you prepare to fire",
  "You’re methodical in adjusting your sights",
  "You’re not rushed as you focus on your target",
  "You’re slow to settle on your mark",
  "You’re careful to track your target",
  "You’re not hurried as you line up the shot",
  "You’re measured in your approach to aiming",
  "You’re slow to commit to the attack",
  "You’re deliberate in your targeting process",
  "You’re steady, but your shot is not immediate",
  "You’re careful to ensure your aim is true",
  "You’re not quick to react to movement",
  "You’re slow to adjust to changes in the target",
  "You’re cautious in your attack preparation",
  "You’re deliberate in lining up your shot"
];

const ratkSpdTier3 = [
  "You hesitate before firing",
  "You’re indecisive as you aim",
  "You pause to consider your shot",
  "You’re thoughtful, but not quick to attack",
  "You’re distracted by options as you aim",
  "You’re caught between targets",
  "You’re slow to settle on a firing solution",
  "You’re uncertain, your aim delayed",
  "You’re not focused, your targeting suffers",
  "You’re second-guessing your shot",
  "You’re slow to decide when to fire",
  "You’re pondering as you line up the attack",
  "You’re caught in analysis, losing time to aim",
  "You’re slow to commit to the shot",
  "You’re unsure, your aim delayed",
  "You’re distracted, your targeting is off",
  "You’re caught in thought, your shot delayed",
  "You’re slow to act on your targeting instincts",
  "You’re hesitant, the moment to fire slipping by",
  "You’re not quick to seize the shot"
];

const ratkSpdTier4 = [
  "You aim with steady focus",
  "You move with careful intent to target",
  "You’re attentive, but not rushed to fire",
  "You’re precise, but not hurried in your aim",
  "You’re methodical, keeping a measured pace as you target",
  "You’re deliberate, your aim controlled",
  "You’re composed, focusing on your shot",
  "You’re focused, but not especially quick to fire",
  "You’re calm, your aim reliable",
  "You’re steady, your targeting well-paced",
  "You’re careful to maintain control as you aim",
  "You’re not rushed, but you’re not slow either to fire",
  "You’re intent on accuracy over speed",
  "You’re measured, your aim smooth",
  "You’re focused on the target at hand",
  "You’re composed, your shot well-timed",
  "You’re attentive, your aim deliberate",
  "You’re steady, your targeting consistent",
  "You’re careful, your pace unhurried as you fire",
  "You’re calm, your shot well-timed"
];

const ratkSpdTier5 = [
  "You attack with practiced confidence",
  "You move with reliable speed to target",
  "You’re focused, your timing solid for the shot",
  "You’re calm under pressure as you aim",
  "You’re sure of yourself, your targeting smooth",
  "You’re ready, your response timely",
  "You’re in control, your aim efficient",
  "You’re prepared, your timing on point",
  "You’re steady, your targeting well-practiced",
  "You’re confident, your response measured",
  "You’re composed, your aim fluid",
  "You’re ready for action, your timing good",
  "You’re focused, your targeting effective",
  "You’re sure-handed, your aim reliable",
  "You’re prepared, your shot well-timed",
  "You’re in control, your targeting consistent",
  "You’re calm, your aim efficient",
  "You’re ready, your response practiced",
  "You’re confident, your shot timely",
  "You’re steady, your targeting reliable"
];

const ratkSpdTier6 = [
  "You react quickly to the target",
  "You move with impressive speed to aim",
  "You’re fast to respond to the opportunity",
  "You’re sharp, your targeting excellent",
  "You’re alert, your aim swift",
  "You’re ready in an instant to fire",
  "You’re practiced, your response quick",
  "You’re fast, your targeting efficient",
  "You’re quick to adapt your aim",
  "You’re efficient, your targeting sharp",
  "You’re rapid, your aim smooth",
  "You’re quick-witted, your response immediate",
  "You’re alert and ready, your aim fast",
  "You’re swift, your targeting impressive",
  "You’re fast-thinking, your response sharp",
  "You’re quick to act, your aim excellent",
  "You’re sharp and focused, your targeting quick",
  "You’re ready in a heartbeat to attack",
  "You’re practiced and quick, your aim efficient",
  "You’re fast on your feet, your targeting excellent"
];

const ratkSpdTier7 = [
  "You attack with remarkable speed",
  "You’re lightning-fast to target",
  "You’re a blur of motion as you aim",
  "You’re swift and sure in your targeting",
  "You’re rapid, your aim almost too fast to follow",
  "You’re quick as a whip, your targeting precise",
  "You’re fast and focused, your aim practiced",
  "You’re a step ahead, your targeting sharp",
  "You’re sharp and quick, your response immediate",
  "You’re ready in a split second to fire",
  "You’re a model of efficiency, your aim fast",
  "You’re quick to react, your targeting flawless",
  "You’re fast and fluid, your aim smooth",
  "You’re a flash of action, your targeting immediate",
  "You’re swift and practiced, your aim excellent",
  "You’re quick on the uptake, your targeting sharp",
  "You’re a blur, your response almost invisible",
  "You’re lightning-quick, your targeting impressive",
  "You’re fast and sure, your aim confident",
  "You’re a master of speed, your targeting instant"
];

const ratkSpdTier8 = [
  "You respond in a blur of targeting motion",
  "You’re a whirlwind of speed as you aim",
  "You’re impossibly fast to line up your shot",
  "You’re a master of quick targeting",
  "You’re a blur of action, your aim perfect",
  "You’re lightning in human form, your targeting precise",
  "You’re a paragon of quickness, your aim flawless",
  "You’re a flash of movement, your targeting instant",
  "You’re a model of efficiency, your aim immediate",
  "You’re a step ahead, your targeting perfect",
  "You’re a whirlwind, your aim almost too fast to see",
  "You’re a master of the quick response, your targeting instant",
  "You’re a blur of skill, your aim practiced",
  "You’re a flash of readiness, your targeting immediate",
  "You’re a paragon of speed, your aim confident",
  "You’re a master of timing, your targeting perfect",
  "You’re a blur of readiness, your aim flawless",
  "You’re a flash of action, your targeting precise",
  "You’re a master of the quick, your aim instant",
  "You’re a whirlwind of skill, your targeting incredibly fast"
];

const ratkSpdTier9 = [
  "You target with the speed and precision of a true marksman",
  "You’re a legend in motion, your aim flawless",
  "You’re a master of quick targeting, your aim perfect",
  "You’re a paragon of precision, your targeting instant",
  "You’re a blur of expertise, your aim practiced",
  "You’re a model of readiness, your targeting instant",
  "You’re a flash of mastery, your aim perfect",
  "You’re a paragon of skill, your targeting flawless",
  "You’re a master of timing, your aim instant",
  "You’re a legend of speed, your targeting immediate",
  "You’re a blur of action, your aim perfect",
  "You’re a paragon of quickness, your targeting instant",
  "You’re a master of the quick, your aim perfect",
  "You’re a whirlwind of expertise, your targeting flawless",
  "You’re a flash of skill, your aim practiced",
  "You’re a paragon of readiness, your targeting perfect",
  "You’re a master of speed, your aim confident",
  "You’re a legend of the quick, your targeting instant",
  "You’re a blur of mastery, your aim flawless",
  "You’re a paragon of action, your targeting perfect"
];

const ratkSpdTier10 = [
  "You react before anyone else can fire",
  "You’re a living legend, your targeting supernatural",
  "You’re a master of the impossible, your aim instant",
  "You’re a force of nature, your targeting beyond compare",
  "You’re a myth in motion, your aim otherworldly",
  "You’re a paragon of perfection, your targeting flawless",
  "You’re a master of the instant, your aim immediate",
  "You’re a legend of the quick, your targeting impossible",
  "You’re a blur of the unreal, your aim supernatural",
  "You’re a flash of the impossible, your targeting instant",
  "You’re a paragon of the quick, your aim mythic",
  "You’re a master of the unthinkable, your targeting instant",
  "You’re a legend of the impossible, your aim perfect",
  "You’re a blur of the legendary, your targeting flawless",
  "You’re a paragon of the instant, your aim perfect",
  "You’re a master of the mythic, your targeting supernatural",
  "You’re a legend of the unreal, your aim impossible",
  "You’re a blur of the mythic, your targeting otherworldly",
  "You’re a paragon of the impossible, your aim flawless",
  "You’re a master of the legendary, your targeting perfect"
];


luckyPhrases = [
  "a bit of good fortune",
  "a slight stroke of luck",
  "a minor lucky break",
  "a tad more fortunate",
  "a little extra luck",
  "a slight favor of fate",
  "luck's gentle nudge",
  "a small lucky charm at play",
  "a modest turn of fortune",
  "a hint of providence",
  "just enough luck to matter",
  "luck by a hair",
  "a whisper of good fortune",
  "some luck",
  "a moment of divine favor",
  "the threads of fate aligning",
  "a fleeting glimpse of destiny",
  "fortune's subtle smile",
  "a spark of cosmic favor",
  "the scales tipping ever so slightly",
  "the winds of chance at your back",
  "a brief dance with lady luck",
  "the stars momentarily aligning",
  "a sliver of exceptional chance",
  "karma's gentle reward",
  "the edge of probability bending",
  "a flash of uncanny timing"
];

sensePhrases = [
  "🍀You feel",
  "🍀You sense",
  "🍀You notice",
  "🍀You perceive",
  "🍀You harness",
  "🍀You channel",
  "🍀You draw upon",
  "🍀You tap into"
];

healthFeelsHalfway = ["your health feels average", "your health is at a mid-point", "your health feels balanced", "you're in fair health", "your health is in the middle", "your health is at an even keel", "your health feels stable but moderate", "you're halfway to full strength", "your health is neither strong nor weak", "your health is moderate", "you're at half strength", "your health stands at the halfway mark", "your vitality is halfway depleted", "you're in a neutral state of health", "your health is balanced at half", "you're halfway from full vigor", "your health is split right down the middle", "you're not in great shape, but not at rock bottom", "your body feels neither strong nor weak, just halfway there", "you're at the middle of your strength"]

healthVeryLow = ["your health is hanging by a few threads", "your vitality is on the brink of collapse", "you're hanging on by a thread", "your health is barely holding together", "your body feels like it's on its last leg", "you're one step away from falling", "your strength is nearly depleted", "you're hanging in there by sheer will", "you're on the edge of total exhaustion", "your health is almost gone, just a breath away from falling", "you're teetering on the edge of unconsciousness", "your body is at its breaking point", "you're seconds away from complete collapse", "your health is almost a memory"];

healthDeathArray = [
  "the world slows as your life ends, and everything goes dark.",
  "time seems to freeze as your life slips away, leaving you in the void of death.",
  "everything blurs as your life gives out, and you fade into nothing.",
  "the world spins around you as your body gives in, you have died.",
  "everything goes silent as you collaspe and die.",
  "the world grows distant as your health drains, and death takes you.",
  "your vision dims and the world around you disappears as death claims you.",
  "the air grows heavy, and with one final breath, you fade from existence.",
  "the ground fades beneath you as your body finally succumbs to death.",
  "the world keeps turning as you fall into the abyss of your own demise.",
  "your body gives way, and with a final breath, death embraces you.",
  "the world fades into stillness, and with it, your life slips away.",
  "your final moments pass as you embrace death.",
  "you surrender to death as your health has fallen to zero."
];

 halfEnergyArray = [
  "you feel drained, like only half of your energy remains.",
  "your energy is running half of what it should be.",
  "you feel a bit sluggish, with just half the energy you normally have.",
  "your vitality feels halved, leaving you feeling sluggish.",
  "you must be running on a hungry stomach, since you feel like you have half your usual energy.",
  "you feel like you've only got half the energy left to keep going.",
  "your energy reserves are half spent, making everything feel slightly more difficult.",
  "you are craving a nap and its affecting you.",
  "you're craving an energy drink considering you're half spent",
  "you feel half as lively.",
  "your body feels a bit tired, like it’s only working with half the energy.",
  "you feel halfway exhausted and could use a meal."
];

exhaustedArray = [
  "you feel almost drained.",
  "your energy is nearly depleted.",
  "you feel close to utterly spent.",
  "you feel almost completely wiped out.",
  "you feel like you can't go on any longer.",
  "your body is fatigued, every movement is a struggle.",
  "you feel utterly exhausted, as if you've run out of fuel.",
  "your energy is an inch away from being used up.",
  "you're so tired, every muscle aches.",
  "you feel like you're at the end of your rope and need rest."
];

exhaustionSleepArray = [
  "you find the need for a place for deep sleep as your body succumbs to its weariness.",
  "you urgently need to crawl into slumber, the exhaustion is too much to bear.",
  "you are about to drift away into unconscious sleep as fatigue takes hold.",
  "you need to get sleep, your body is about to let go of its fight with exhaustion.",
  "you need to go under rest, the overwhelming tiredness is pulling you.",
  "you need to head into sleep, your mind is shutting down as exhaustion claims you.",
  "you need to lay down, the exhaustion almost pulling you into a deep, much-needed rest.",
  "you require deliberate action to lie down, and wish for sleep to come quickly, your body finally giving in.",
  "you mind needs you to make your way into sleep, the exhaustion is too much to resist.",
  "you need to purposely move into slumber, your mind surrendering to the weight of your fatigue.",
  "you urgently require deliberate sleep, the fatigue finally overtaking you.",
  "you need to settle into sleep, your body letting go of the day’s exhaustion.",
  "you need to sink into sleep, the weight of your weariness dragging you under.",
  "you need to step into slumber, your exhaustion becoming too much to fight.",
  "you need to surrender to sleep, the exhaustion finally winning over your body.",
  "you need to take a deep breath and fall into sleep, your body letting go.",
  "you need to turn in immediately, and sleep will claim you effortlessly.",
  "you need to transition into slumber, else your body will fail you."
];

bodyParts = [
  // Standard humanoid body parts
  "abdomen", "achilles tendon", "ankle", "arm", "arteries", "back", "biceps", "bladder", "buttocks", "body",
  "calf", "cheek", "chest", "chin", "collarbone", "deltoid", "diaphragm", "ear", "elbow", "esophagus",
  "eyebrow", "eyelid", "face", "fingers", "foot", "flesh", "forearm", "forehead", "gums", "gut", "groin", "hamstring",
  "hand", "head", "heart", "heel", "hip", "intestines", "jaw", "kidney", "knee", "knuckles", "leg",
  "lips", "liver", "lungs", "lung", "lower back", "nape", "neck", "nose", "palm", "pancreas", "pelvis",
  "quadriceps", "ribs", "scapula", "shin", "shinbone", "shoulder", "side", "skull", "solar plexus",
  "spine", "spleen", "stomach", "sternum", "tailbone", "teeth", "temple", "thigh", "throat", "thumb",
  "toes", "triceps", "upper back", "veins", "waist", "wrist",

  // Fantasy/Sci-Fi Races
  "antlers", "barb", "beak", "carapace", "chitin", "claw", "crest", "eye stalk", "fang", "feathers",
  "fin", "frill", "gill", "horn", "hoof", "mandible", "membrane", "proboscis", "scales", "shell",
  "snout", "spikes", "stinger", "talon", "tail", "thorax", "trunk", "tusk", "whiskers", "wing"
];

beginnerPsykerSpells = ["telepathy", "telekinesis", "pyrokinesis", "psychic shield", "mind control", 
  "clairvoyance", "psychic blast", "aura reading", "psychic healing", "psychic barrier", "psychic projection", 
  "teleportation", "psychic scream", "psychic manipulation", "psychic ward" ];

beginnerTechSkills = [
  "debug", "hack", "defragment", "reboot", "code", "encrypt", "decrypt", "scan", "analyze", 
];

beginnerEngineerSkills = [
  "repair", "calibrate", "maintain", "upgrade", "assemble", 
  "disassemble", "construct", "deconstruct", "build", "dismantle", "refurbish", "refit", 
  "reconfigure", "rebuild", "reconstruct", "reengineer", "retool"
];


const skillPower1 = [
  "[Skill], amateurish.",
  "[Skill], tentative and raw.",
  "[Skill] flickers in.",
  "A soft hum of [Skill] stirs and buzzes.",
  "You fumble slightly as [Skill] begins to form.",
  "[Skill] shly whispers through the air",
  "You exude some inexperience with [Skill].",
  "A cute display of [Skill] executes.",
  "You manage to cast your [Skill].",
  "'[Skill], let's try this!'",
  "You feel the corruption consuming your body and mind as you bet your experience on [Skill].",
  "You allow the corruption to flow through you, fueled by hope for [Skill].",
  "Like a student of magic, your [Skill] executes.",
  "A steady show magic unfolds as [Skill] is casted.",
  "A cautious burst of magic announces your [Skill] skill."
];

const skillPower2 = [
  "You manage a quiet execution of [Skill].",
  "[Skill] winds from your fingertips.",
  "The atmosphere around you shifts in response to your [Skill].",
  "The air around you shifts subtly as [Skill] activates.",
  "[Skill] activates.",
  "Your [Skill] moves with purpose and grace.",
  "You call on [Skill], and it obeys.",
  "Your display of [Skill] arrives.",
  "Your [Skill] responds to your aura.",
  "You wield [Skill] with growing assurance.",
  "The power of [Skill] resonates calmly around you.",
  "You watch your skill [Skill] execute."
];

const skillPower3 = [
  "You perform [Skill] with steady control.",
  "[Skill] manifests with focus and clarity.",
  "There’s balance in your motion as [Skill] takes shape.",
  "You cast [Skill] like a practiced movement.",
  "The air listens as your [Skill] begins to exert.",
  "Your [Skill] shows practice.",
  "The flow of [Skill] feels reliable and calm.",
  "[Skill] appears with ease and intention.",
  "You hesitate slightly, but [Skill] still forms.",
  "[Skill] emerges with some effort.",
  "You begin to shape [Skill], slowly finding your rhythm."
];

const skillPower4 = [
  "[Skill] flows from you with growing strength.",
  "You shape [Skill] with visible intent.",
  "A steady pulse of [Skill] radiates outward.",
  "[Skill] stretches from your hands, confident and sure.",
  "Your presence deepens as [Skill] gathers momentum.",
  "[Skill] begins to answer your deeper will.",
  "Your hands move with purpose as [Skill] grows.",
  "You steady yourself as [Skill] begins to surge.",
  "A touch of control helps bring [Skill] into focus.",
  "[Skill] begins to form, guided by mild focus.",
  "You call forth [Skill] with some concentration."
];

const skillPower5 = [
  "Your [Skill] cuts through the moment with precision.",
  "You command [Skill] like a seasoned wielder.",
  "[Skill] echoes through the space with purpose.",
  "The energy of [Skill] answers your call instantly.",
  "You strike the air with [Skill], crisp and controlled.",
  "Your [Skill] shows diligence.",
  "[Skill] weaves into the moment with clarity.",
  "You place [Skill] with practiced poise.",
  "[Skill] arrives a little delayed but steady.",
  "Your posture slips slightly as [Skill] ignites.",
  "[Skill] builds slower than usual but holds form."
];

const skillPower6 = [
  "[Skill] bursts forward with confident energy.",
  "You unleash [Skill] with clear focus and strength.",
  "[Skill] rushes from you, drawing attention.",
  "The air crackles as your [Skill] expands outward.",
  "You drive [Skill] forward like a rolling wave.",
  "You propel [Skill] with unwavering purpose.",
  "[Skill] ripples outward with firm resolve.",
  "You steady your stance as [Skill] builds pressure.",
  "[Skill] sparks briefly before catching stride.",
  "A slight delay precedes your release of [Skill].",
  "Your grip tightens as [Skill] begins to respond."
];

const skillPower7 = [
  "[Skill] tears through the moment like thunder.",
  "You channel [Skill] with explosive force.",
  "Your [Skill] roars out, wild yet honed.",
  "The air begins to quivers under your [Skill]’s advance.",
  "A storm of [Skill] arcs from your stance.",
  "You shape [Skill] like a crashing tide.",
  "[Skill] erupts with raw, controlled fury.",
  "[Skill] briefly stutters before finding its power.",
  "You summon [Skill] with effort, then let it surge.",
  "[Skill] starts less violently, but ramps up quickly.",
  "A sharp breath helps you anchor your [Skill]."
];

const skillPower8 = [
  "Your [Skill] lights the scene with brilliance.",
  "[Skill] surges like a tidal force through your hands.",
  "You bend the battlefield with the strength of your [Skill].",
  "Light fractures and reforms around your [Skill].",
  "Everything shifts to accommodate your [Skill]’s presence.",
  "[Skill] pulses with undeniable clarity.",
  "You channel [Skill] with a sense of destiny.",
  "Some strain precedes your full release of [Skill].",
  "You feel [Skill] climb before unleashing.",
  "The brilliance of [Skill] dims briefly before growing.",
  "It takes a moment, but [Skill] aligns with your will."
];

const skillPower9 = [
  "[Skill] blazes with overwhelming intensity.",
  "You become a beacon of [Skill], feared and admired.",
  "[Skill] reverberates like an anthem through space.",
  "You wield [Skill] like a blade of pure will.",
  "Even time seems to hesitate at your display of [Skill].",
  "[Skill] radiates from you like a final warning.",
  "The sheer volume of [Skill] overwhelms the moment.",
  "Your [Skill] flares, briefly uneven, then locks into place.",
  "You struggle slightly, but [Skill] dominates nonetheless.",
  "An edge of chaos tempers your display of [Skill].",
  "[Skill] takes a moment to stabilize before blazing."
];

const skillPower10 = [
  "[Skill] erupts with grandeur.",
  "You are the epicenter of myth, and [Skill] is your signature.",
  "The world bends as [Skill] pours from your soul.",
  "[Skill] transcends power—it becomes legend in motion.",
  "You don’t use [Skill]; you **are** [Skill], made manifest.",
  "Your sage mastery of [Skill] speaks for itself.",
  "[Skill] reshapes the moment like a sovereign decree.",
  "You command [Skill] as if born to it.",
  "A flicker of effort breaks through before [Skill] takes hold.",
  "There’s a crack in your flow, but [Skill] still triumphs.",
  "Your form falters—but [Skill] holds, vast and imposing."
];

const harnessSkill = [
  "You attempt to harness your [Skill].",
  "You attempt a quickened execution of [Skill].",
  "You attempt to shortcut cast [Skill].",
  "Your shortened incantation of [Skill] attempts to execute.",
  "You try to quick cast [Skill].",
  "You focus intently to channel [Skill] rapidly.",
  "You speed up your [Skill] casting.",
  "You hasten your gestures, trying to control [Skill].",
  "You push your limits to harness [Skill] faster.",
  "Your quickened [Skill] flickers in.",
  "You grasp at the edge of your [Skill], trying to unleash it swiftly.",
  "Your hurried words shape your [Skill] skill.",
  "You risk a rapid cast, hoping to avoid misfire.",
  "You rush your concentration, testing the speed of [Skill].",
  "You force [Skill] into a quicker form, with successful execution."
];

/////////////////////////////////////////////////////////////////////////////////////

/// TAS STANDARD FUNCTIONS
//Input /start unlocks the script else script naturally locked
function unlockScript(key){ 
  if (state.startScript == false) {
    if (key.includes("/start")) {
      state.startScript = true;
      text = text + "\n 🔓 TAS Script Unlocked!";
    }
  }
  return text;
}

//Detect input command /end to lock script
function lockScript(key){ 
  if (state.startScript == true) {
    if (key.includes("/end")) {
      state.startScript = false;
      text = text + "\n 🔒 TAS Script Locked!"
    }
  }
  return text;
}

//detect /help and display help
function helpCommandInput_TSS(text){
  if(text.includes("/help stats")){
    state.commandCenter_TSS = 
    `
    <<
    📊 Player Stats Guide

    - 📥 Type "Player Stats" in the Story Cards to view your current stats.
    - 🔄 Stats auto-update based on natural player input and context.
    - ✏️ To manually adjust a stat, use the format: STAT: x/maxX.
    - 🗒️ Stat change logs appear in the notes of the Player Stats Story Card.

    🧠 Gameplay Mechanics

    - ❤️ Health and 🔵 Corruption regenerate every turn.
    - ⚡ Energy decreases every turn.
    - ⚠️ Low Health or Energy leads to consequences.
    - 📈 Stats used in actions gain exp. Experience scales exponentially lower as your stats increase.
    - 🎓 When a stat is maxed, exp overflows to your main EXP pool for leveling up instead.
    - 🆙 Leveling up increases all max stats.

    📐 Scaling & Calculations

    - 🧠 Corruption scales with INTL.
    - 🛡️ X DEF = X/2 % damage reduction.
    - ➕ DEF above 100 reduces damage by an extra 0.01% per 10 points.
    - 🍀 Each point in LCK gives a 1% chance of a lucky boost.
    >>
    `
 
  }
  else if(text.includes("/help skills")){
    state.commandCenter_TSS = 
    `
    <<
    🎯 Skills System Guide

    
    - 📝 Edit skills in the Story Card using the format: "Skill Name (Lvl)".
    - 📈 Use skills to gain EXP — progress is logged in the Story Card.
    >>
    `
  }
  
  else if (text.includes("/help inventory")) {
  state.commandCenter_TSS = 
  `
  <<
  📦 Inventory Help

  - Store items by typing: "You [store words]... [item name]... [inventory words]."
  - Include a number to specify quantity. Ex: "You put 2 apples in your bag."
  - Edit your inventory in the story card using the format: "Item Name (Amt)".
  - Weapons are automatically equipped when stored if no weapon is currently equipped.
  - To use an item, type: "You [use words]... [item name]... [inventory words]."
  - To drop an item, type: "You [drop words]... [item name]... [inventory words]."
  >>
    `

  }
  else if (text.includes("/help actions")) {
    state.commandCenter_TSS = 
    `
    <<
    🎬 Action System Help

    - Item, and skill usage requires name matching (exact or partial).
    - Vague actions are taken literally. Example: "You slice it" (slice with what?).
    - Cast skills: "You [cast verb] [skill name]."
    - Rest to recover HP, CP, and energy:
      • Light rest, moderate rest, full rest yield different recovery levels.
      • Format: "You [enter words] [sleep words]."
    - Use consumables for healing/energy. Example: "You drink a Mythical potion."
    - Use skills on yourself to heal. Format: "You [heal word] [yourself] [skill]."
    - ATK & SPD:
      • +10 ATK & SPD → stronger attacks
      • +10 SPD → faster actions, better dodging
      • Attacking and dodging costs energy based on your RATK or ATK, and SPD
    - Weapons
    - Placing a weapon into your inventory allows you to equip it. Equip a weapon by drawing it as in "I draw my laspistol" 
    - Once a weapon is equipped you do not need to specify which weapon you are attacking with your attacks will use ammunition from that weapon's story card.
    - Unequip a weapon by returning it to your holster as in "I return my laspistol to it's holster"
    - You may toggle fire modes on appropriate weapons by saying "I select" or "I toggle burst fire" or "overcharge". Burst fire fires three rounds, overcharge consumes all remaining ammunition
    - You may fire multiple times in one action by saying "I fire twice" or "I fire three times etc"
    - Laser weapons reload with power cells. 1 power cell = full weapon charge
    >>
    `
  }
  else if (text.includes("/help keywords")) {
    state.commandCenter_TSS = 
    `
    <<
    
    🔎 castWords:\n${castWords}
    🔎 equipWords:\n${equipWords}
    🔎 invWords:\n${invWords}
    🔎 attackWords:\n${attackWords}
    🔎 consumeWords:\n${consumeWords}
    🔎 restingWords:\n${restingWords}
    🔎 rangedattackWords:\n${rangedattackWords}
    >>
    `
  }
  else if (text.includes("/help")) {
    state.commandCenter_TSS = 
    `
    <<
    TRUE AUTO STATS RPG SCRIPT BY Yi1i1i
    🛠️ Script Commands

    - /start — Starts the script
    - /end — Stops the script
    - /help stats — Stat mechanics and usage
    - /help skills — Skill casting and upgrades
    - /help inventory — Storing and managing items
    - /help actions — Combat, healing, resting, and usage behaviors
    - /help keywords — Command triggers
    - /reset — Resets game over state allowing you to continue your playthrough after modirying your stats.
    >>
    `
  }
   else if (text.includes("/reset")) {
    resetGameOverState();
    state.msgHolder += "Game over state reset. You may continue your adventure!\n";
  }
}

function helpCommandOutput_TSS(text){
  if(state.commandCenter_TSS){
    text = state.commandCenter_TSS;
  }
  delete state.commandCenter_TSS
  return text;
}

// Increment turn counter at end of onOutput
function turnCounter(){
  state.turnCount += 1;
  log("state.turnCount: " + state.turnCount);
}

// Remove script texts to clean AI context
function removeAngleText(text) {
  return text.replace(/<<[\s\S]*?>>/g, '');
}

// Function to capitalize first letter of a string
function capitalizeFirst(str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
}

///Function to return all indices of one target in array 
function indicesOf(arr,target){  
    indices = [];
    for (let i = 0; i < arr.length; i++) {
        if (arr[i] === target) {
            // Found the word, store its index
            indices.push(i);
        }
    }

    if(indices.length == 0){
        return null;
    }
    else{
        return indices; //arr
    }
    
}

/**
 * Injects a story card's contents into the context only if not already present.
 * @param {string} cardTitle - The title of the story card to inject.
 * @param {string} context - The current context string.
 * @returns {string} - The new context string with the card's data prepended if not already present.
 */
function injectStoryCardToContext(cardTitle, context) {
  const sc = storyCards.find(sc => sc.title === cardTitle);
  if (!sc) return context; // Card not found

  // Prepare the card's text block
  let cardText = "";
  if (sc.description && sc.description.trim() !== "") {
    cardText += `<<${cardTitle} Description>>\n${sc.description}\n`;
  }
  if (sc.entry && sc.entry.trim() !== "") {
    cardText += `<<${cardTitle}>>\n${sc.entry}\n`;
  }

  // Check if cardText (ignoring whitespace) is already in context
  const normalizedContext = context.replace(/\s+/g, ' ').toLowerCase();
  const normalizedCardText = cardText.replace(/\s+/g, ' ').toLowerCase();

  if (normalizedContext.includes(normalizedCardText.trim())) {
    return context; // Already present, skip adding
  }

  // Otherwise, prepend cardText
  return cardText + context;
}

/**
 * Injects an instruction for the AI to always reference the equipped weapon's story card for stats.
 * This helps prevent the AI from inventing ammo/condition values.
 * @param {string} context - The current context string.
 * @returns {string} - The new context string with the instruction prepended if needed.
 */
function injectEquippedWeaponInstruction(context) {
  log("injectEquippedWeaponInstruction called"); // Debug log
  const eqWeapon = retrieveEquippedWeaponFromSC();
  if (!eqWeapon) {
    log("No equipped weapon found.");
    return context;
  }

  // Find the weapon story card
  const weaponSC = storyCards.find(sc => sc.title.toLowerCase() === eqWeapon.toLowerCase());
  if (!weaponSC) {
    log(`No story card found for equipped weapon: ${eqWeapon}`);
    return context;
  }

  // Use a more generic check that will match regardless of weapon name
  if (!context.includes("#ALWAYS reference the equipped weapon's story card")) {
    const instruction = `<SYSTEM> #ALWAYS reference the equipped weapon's story card ("${eqWeapon}") for ammunition, condition, and weapon stats. Do NOT invent or estimate these values. Use the exact numbers from the story card entry:\n${weaponSC.entry}. Avoid making assumptions about the weapon's state or capabilities. Condition and ammunition counters are for reference only. Avoid mentioning weapon condition stat or remaining ammunition in the story.#\n</SYSTEM>\n`;
    log(`Injecting equipped weapon instruction for: ${eqWeapon}`);
    log("Injected SYSTEM instruction:\n" + instruction);
    return instruction + context;
  }
  log("Instruction already present in context.");
  return context;
}

/// Returns true if a "you" word appears within N words before or after the match index
function isPlayerContext(text, matchIndex, matchLength, windowSize = 10) {
  const words = text.split(/\s+/);
  // Find the word index of the match
  let charCount = 0, matchWordIndex = -1;
  for (let i = 0; i < words.length; i++) {
    charCount += words[i].length + 1; // +1 for space
    if (charCount > matchIndex) {
      matchWordIndex = i;
      break;
    }
  }
  if (matchWordIndex === -1) return false;
  // Check window before and after
  const start = Math.max(0, matchWordIndex - windowSize);
  const end = Math.min(words.length, matchWordIndex + windowSize + 1);
  for (let i = start; i < end; i++) {
    if (youWordsRegex.test(words[i])) return true;
  }
  // Direct check: "your" appears within 2 words before the match
  if (matchWordIndex >= 1 && youWordsRegex.test(words[matchWordIndex - 1])) return true;
  if (matchWordIndex >= 2 && youWordsRegex.test(words[matchWordIndex - 2])) return true;
  return false;
}

//With a words arr and arr of targets, find all indices for each target in word arr and put them together in one arr
function indicesOfTargets(wordsArr,targetWordsArr){
  allTargetsIndicesArr = [];

  //Loop through each target word and store their indices from words arr in an array
  targetWordsArr.forEach(word => {
    //unused target words return null so filter them out of index holder
    if(indicesOf(wordsArr,word)){
      //indicesOf returns an array, alltargetindices becomes an array of arrays so concat them
      allTargetsIndicesArr = allTargetsIndicesArr.concat(indicesOf(wordsArr,word));
      allTargetsIndicesArr.sort((a, b) => a - b);
    }
  });

  //if no indices found return null
  if(allTargetsIndicesArr.length <= 0){
    return null;
  }

  return allTargetsIndicesArr;
}

//Input a string and remove punctuation
function removeSpecificPunctuation(str) {
  return str.replace(/[.><,!?;:"()\n]/g, " ");
}

//Return true or false for first letter capitalized
function isFirstLetterCapitalized(word) {
  if (!word) return false;  // Return false for empty string
  return word.charAt(0) === word.charAt(0).toUpperCase();
}

function randomInt(min, max) {
  return Math.floor(Math.random() * (max - min + 1)) + min;
}

function randomFloat(min, max){
  return Math.random() * (max - min) + min;
}

// Check for targets in text and split text string into words arr if there are. Replace all target words with first target word if unlocking is true
function findTargetsThenSplit(text, targetWordsArr, wordsArrHolder, unlocking) {
  if (text == null) return null;

  yesSplit = false

  // Remove punctuation first to standardize text processing
  cleanText = removeSpecificPunctuation(text); //str

  // loop through target words and check if text has target
  targetWordsArr.forEach(target => {
    targetRegex = new RegExp(`\\b${target}\\b`, "gi");
    
    // If text has target, set yessplit true
    if(targetRegex.test(cleanText)){
      // Optional replace large target words with first target word
      if (unlocking === true && target.split(" ").length > 1) {
        cleanText = cleanText.replace(targetRegex, targetWordsArr[0]);
      }

      yesSplit = true;
    }
  });
  //log("cleanText postregex: " + cleanText);
  //log("yesSplit: " + yesSplit);

  // Split text if target was found
  if (yesSplit){
    wordsArrHolder = cleanText.split(/\s+/).filter(word => word.trim() !== "");
    //console.log("wordsArrHolder: ", wordsArrHolder);
    return wordsArrHolder;
  }
  else{
    return null;
  }

}

//Give an arr of targets and a string, clean text and check if string has a target
function cleanStringCheckForTargets(targetWordsArr, text) {
  if (text == null) {return false};

 let wordsArr = text.replace(/[.,!?]/g, '').replace(/\s+/g, ' ').trim().split(' ');
const numberWordsRegex = /^(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand)$/i;
if (numberWordsRegex.test(wordsArr[0])) {
  wordsArr[0] = wordsToNumber(wordsArr[0]).trim();
}
let cleanText = wordsArr.join(' ');

  // Loop through target words
  for (let target of targetWordsArr) {
    let targetRegex = new RegExp(`\\b${target}\\b`, "gi");
    //log(target);

    // Check if target is found in the text
    if (targetRegex.test(cleanText)) {
      return true; // Immediately return true if a match is found
    }
  }

  return false; // Return false if no matches are found
}

//Given a words arr, checks if there is a "you" (player context) a num specified before target indicesarr
function checkYouBeforeIndicesArr(wordsArr, indicesArr, numWordsBefore) {
  for (let i = 0; i < indicesArr.length; i++) {
    const currentIndex = indicesArr[i];
    // Store words from current target index up to specified indices before them without going out of bounds into a holder
    let prevWordsHolder = wordsArr.slice(Math.max(0, currentIndex - numWordsBefore), currentIndex);
    // Use youWordsRegex for player context detection
    if (prevWordsHolder.some(word => youWordsRegex.test(word))) {
      return true;
    }
  }
  return false;
}

//Given a words arr, checks if there is a "and" a num specificed before target indicesarr
function checkAndBeforeIndicesArr(wordsArr,indicesArr,numWordsBefore){
  //loop through array of target indices
  for(i = 0; i < indicesArr.length; i++){
    //get the current target index
    currentIndex = indicesArr[i];

    // Store words from current target index up to specified indices before them without going out of bounds into a holder
    let prevWordsHolder = wordsArr.slice(Math.max(0, currentIndex - numWordsBefore), currentIndex);

    //Check in holder containing words before current target index if it has "and"
    if(prevWordsHolder.includes("and")){
      return true;
    }
  }

  return false;
}

//Counts how frequent words appear in text and decays less appeared words
function mostFrequentOutputWords(text){
  // Split text into words and clean
  outText = removeSpecificPunctuation(text).split(" ");

  // Include uppercase stop words
  capitalStopWords = [];
  capitalStopWords = stopWords.map(word => word.charAt(0).toUpperCase() + word.slice(1));

  // Remove stop words and player context words using regex
  outText = outText.filter(word => 
    ![...stopWords, ...capitalStopWords].some(stopWord => stopWord === word) &&
    !youWordsRegex.test(word)
  );
  
  //Holders
  state.freqWords = state.freqWords || [];
  state.wordWeights = state.wordWeights || [];

  //Push new words and weight to holders
  outText.forEach(word => {
    if(!state.freqWords.includes(word) && word != ""){
      state.freqWords.push(word);
      state.wordWeights.push(1);
    }
  });

  //Words that appear again increment over time
  state.freqWords.forEach((word,ii) => {
    if(outText.includes(word)){
      state.wordWeights[ii]++;
    }
    else{
      //Decay factor for unused words
      state.wordWeights[ii]--;
    }
  });

  //Remove decayed words and weights from holders
  state.freqWords = state.freqWords.filter((word, ii) => state.wordWeights[ii] >= 0);
  state.wordWeights = state.wordWeights.filter((count) => count >= 0);

}

//sort two linked arrs and display each element together in console
function sortTwoLinkedArrForConsole(arr1,arrToSort){
  //Combine for console log debugging
  combined = arr1.map((word, index) => [word,arrToSort[index]]);
  // Sort the combined array based on the second element (arrToSort values)
  combined.sort((a, b) => a[1] - b[1]);  // Sort by count (ascending)
  // Extract sorted arr1 and arrToSort from the combined array
  arr1 = combined.map(item => item[0]);
  arrToSort = combined.map(item => item[1]);
  arr1.forEach((word,ind)=>{
    log(arr1[ind] + ": " + arrToSort[ind]);
  })
}

// Check if any guest is distance after any home, and push weight into weightarr if true
function isAfterIndex(guestIndices, homeIndices, minDis, maxDis, weightIfTrue, arrOfWeights) {
  if(guestIndices && homeIndices){
    guestIndices.forEach((g, index) => {
      homeIndices.forEach((h, index2) => {
        // Check if the guest element is after the home element within the given distance
        if (g - h <= maxDis && g - h >= minDis) {
          arrOfWeights[index] += weightIfTrue;
        }
      });
    });
  }
}

// Check if any guest is distance before any home, and push weight into weightarr if true
function isBeforeIndex(guestIndices, homeIndices, minDis,maxDis, weightIfTrue, weightArr) {
  if(guestIndices && homeIndices){
    guestIndices.forEach((g, index) => {
      homeIndices.forEach((h, index2) => {
        // Check if the guest element is before the home element within the given distance
        if (g - h >= -maxDis && g - h <= -minDis) {
          weightArr[index] += weightIfTrue;
        }
      });
    });
  }
}

function findClosestNumberBefore(arr, index) {
  for (let i = index - 1; i >= 0; i--) {
    const match = arr[i].match(/(\d+(\.\d+)?)/); // match integer or decimal
    if (match) {
      return Number(match[1]);
    }
  }
  return null; // no number found before index
}

function wordsToNumber(text) {
  const smallNumbers = {
    "zero": 0, "one": 1, "two": 2, "three": 3, "four": 4, "five": 5,
    "six": 6, "seven": 7, "eight": 8, "nine": 9, "ten": 10,
    "eleven": 11, "twelve": 12, "thirteen": 13, "fourteen": 14,
    "fifteen": 15, "sixteen": 16, "seventeen": 17, "eighteen": 18, "nineteen": 19
  };

  const tens = {
    "twenty": 20, "thirty": 30, "forty": 40, "fifty": 50,
    "sixty": 60, "seventy": 70, "eighty": 80, "ninety": 90
  };

  const multipliers = {
    "hundred": 100,
    "thousand": 1000,
    "million": 1000000,
    "billion": 1000000000
  };

  // Match possible number phrases like "two hundred and twenty-five"
  const numberWordsRegex = new RegExp(
    '\\b(?:(?:zero|one|two|three|four|five|six|seven|eight|nine|ten|' +
    'eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|' +
    'twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|' +
    'hundred|thousand|million|billion|trillion|[-])+\\s*)+\\b',
    'gi'
  );

  // Process a number phrase like "one hundred twenty three"
  function parseNumberPhrase(phrase) {
    const words = phrase.toLowerCase().replace(/-/g, ' ').split(/\s+/);
    let total = 0, current = 0;

    for (let word of words) {
      if (smallNumbers[word] != null) {
        current += smallNumbers[word];
      } else if (tens[word] != null) {
        current += tens[word];
      } else if (word === "hundred") {
        current *= 100;
      } else if (multipliers[word]) {
        current *= multipliers[word];
        total += current;
        current = 0;
      }
    }


    return total + current + " ";

  }

  // Replace all matching phrases with numeric values
  return text.replace(numberWordsRegex, match => {
    return parseNumberPhrase(match);
  });
}

function getDigitIndices(wordsArray) {
  const digitIndices = [];

  for (let i = 0; i < wordsArray.length; i++) {
    if (/^\d+$/.test(wordsArray[i])) {
      digitIndices.push(i);
    }
  }

  return digitIndices;
}

// --- Levenshtein Distance Helper ---
function levenshtein(a, b) {
    if (a.length === 0) return b.length;
    if (b.length === 0) return a.length;
    const matrix = [];
    for (let i = 0; i <= b.length; i++) matrix[i] = [i];
    for (let j = 0; j <= a.length; j++) matrix[0][j] = j;
    for (let i = 1; i <= b.length; i++) {
        for (let j = 1; j <= a.length; j++) {
            if (b.charAt(i - 1) === a.charAt(j - 1)) {
                matrix[i][j] = matrix[i - 1][j - 1];
            } else {
                matrix[i][j] = Math.min(
                    matrix[i - 1][j - 1] + 1,
                    matrix[i][j - 1] + 1,
                    matrix[i - 1][j] + 1
                );
            }
        }
    }
    return matrix[b.length][a.length];
}

// --- Fuzzy Inventory Item Matcher ---
function findBestInventoryMatch(input, inventoryItems) {
    input = input.toLowerCase().replace(/[^a-z0-9 ]/gi, '');
    let inputTokens = input.split(/\s+/).filter(Boolean);

    let bestScore = 0;
    let bestItems = [];

    // First, use token overlap
    for (let item of inventoryItems) {
        let itemTokens = item.toLowerCase().replace(/[^a-z0-9 ]/gi, '').split(/\s+/).filter(Boolean);
        let overlap = inputTokens.filter(token => itemTokens.includes(token)).length;
        if (overlap > bestScore) {
            bestScore = overlap;
            bestItems = [item];
        } else if (overlap === bestScore && overlap > 0) {
            bestItems.push(item);
        }
    }
    // If only one best match, return it
    if (bestItems.length === 1) return bestItems[0];
    // If multiple, use Levenshtein distance as tie-breaker
    if (bestItems.length > 1) {
        let minDist = Infinity;
        let best = bestItems[0];
        for (let item of bestItems) {
            let dist = levenshtein(input, item.toLowerCase());
            if (dist < minDist) {
                minDist = dist;
                best = item;
            }
        }
        return best;
    }
    // No match found
    return null;
}


///////////////////////////START OF WEAPON EQUIP DETECTION///////////////////////////////////////
  //Detects equip/unequip commands and updates the Equipped Weapon story card.
  
function detectWeaponEquip(text) {
    // Normalize input for matching
    let cleanText = text.toLowerCase();

    // Get inventory items from Player Inventory story card
    const invSC = storyCards.find(sc => sc.title === "Player Inventory");
    let inventoryItems = [];
    if (invSC && invSC.entry) {
        let matches = invSC.entry.matchAll(/(.+?)\s*\(.*?(\d+(?:\.\d+)?).*?\)/g);
        for (const match of matches) {
            let itemName = match[1].replace(/\b(the|a|an|my|your)\b/gi, '').trim().toLowerCase();
            inventoryItems.push(itemName);
        }
    }

    // Get weapon names from weapon story cards
    let weaponNames = getWeaponNamesFromStoryCards();

    // Check for equip/unequip commands
    let equipCmd = /(equip|draw|ready|wield|hold|unsheath|arm)\s+([\w\s\-']+)/i;
    let unequipCmd = /(unequip|holster|put away|stow|sheath|disarm|return)\s+(?:my|your)?\s*([\w\s\-']+)?/i;

    let equippedWeapon = retrieveEquippedWeaponFromSC();
if (!equippedWeapon || typeof equippedWeapon !== "string" || equippedWeapon.trim() === "") {
  // Handle the case where no weapon is equipped
  equippedWeapon = null;
}

    // Handle unequip
    if (unequipCmd.test(cleanText)) {
        storeEquippedWeaponToSC("");
        state.equippedWeapon = null;
        state.msgHolder += `You put away your weapon.\n`;
        return text;
    }

    // Handle equip
    let equipMatch = cleanText.match(equipCmd);
    if (equipMatch) {
        let inputWeapon = equipMatch[2].trim().toLowerCase();
        // Fuzzy match inventory item to weapon card
        let bestMatch = findBestInventoryMatch(inputWeapon, inventoryItems.filter(item =>
            weaponNames.some(w => item.includes(w) || w.includes(item))
        ));
        if (bestMatch) {
            // Find the matching weapon card name
            let matchedWeapon = weaponNames.find(w => bestMatch.includes(w) || w.includes(bestMatch));
            if (matchedWeapon) {
                storeEquippedWeaponToSC(matchedWeapon);
                state.equippedWeapon = matchedWeapon;
                state.msgHolder += `You equip your ${matchedWeapon}.\n`;
                return text;
            }
        }
         state.msgHolder += `You do not have that weapon in your inventory.\n`;
        text += " You do not have that weapon in your inventory.";
        return text;
    }

    return text;
}

///////////////////////////END OF WEAPON EQUIP DETECTION///////////////////////////////////////


//Function to get plr race
function getPlrRace(){
  //Get PE text
  plotEssentials = state.memory.context.toLowerCase();
  
  // Default race to human
  race = "human";

  //Get plr race from PE
  raceNames.forEach(name => {
    if(plotEssentials.includes(name.toLowerCase() + " race")){
      race = name.toLowerCase();
    }
  });

  // Remove spaces in race name
  race = race.replace(/\s+/g, '');

  return race;
}

/////////////////////////////////////////////////////////////////////////////////////

//Initialize player modifiers
state.playerModifiers = state.playerModifiers || {
  lvlMod: 0,
  hpMod: 0,
  cpMod: 0,
  epMod: 0,
  atkMod: 0,
  ratkMod: 0,
  defMod: 0,
  spdMod: 0,
  lckMod: 0,
  intlMod: 0
};

const raceMods = {
  human: {
    lvlMod: 0,
    hpMod: 0,
    cpMod: 0,
    epMod: 0,
    atkMod: 0,
    ratkMod: 0,
    defMod: 0,
    spdMod: 0,
    lckMod: 0,
    intlMod: 0
  },
  
};

modKeys = ["lvlMod", "hpMod", "cpMod", "epMod", "atkMod", "ratkMod", "defMod", "spdMod", "lckMod", "intlMod"];
raceNames = ["Human"];
statKeysForMod = ["lvl", "hp", "cp", "ep", "atk", "ratk", "def", "spd", "lck", "intl"];


//CREATE new sc with player Modifiers if sc doesnt exist
function createIfNoModifierSC(){
  if (!storyCards.find(sc => sc.title === "Player Modifiers")) {
    // If "Player Modifiers" card doesn't exist, create it
    addStoryCard("Player Modifiers", "Blank", "Player Stats");

    plrRace = getPlrRace();

    // Fetch the "Player Modifiers" card
    const modSC = storyCards.find(sc => sc.title === "Player Modifiers");
    modSC.description = `Format for Modifying: Modifier: num\nModifiers influence your starting stats and modify the exp you receive.\nYour race is ${capitalizeFirst(plrRace)}.`;

    //Set player modifier values in SC based on their race
    modKeys.forEach(key => {
      state.playerModifiers[key] = raceMods[plrRace][key];
    });

    // Apply initial race mods to stats and display them to sc
    statKeysForMod.forEach(key => {
      // Modify normal stat
      temp1 =  state.playerStats[key] * state.playerModifiers[key + "Mod"]/100;
      state.playerStats[key] = state.playerStats[key] + temp1;
      state.playerStats[key] = Math.round(state.playerStats[key] * 100) / 100;

      // Modify max stats
      maxKey = "max" + capitalizeFirst(key);
      temp2 = state.playerStats[maxKey] * state.playerModifiers[key + "Mod"]/100;
      state.playerStats[maxKey] = state.playerStats[maxKey] + temp2;
      state.playerStats[maxKey] = Math.round(state.playerStats[maxKey] * 100) / 100;

    });

    storeStatsToSC();
  }
}

//STORES and displays the modifiers to player in sc
function storeModifiersToSC(){
  //Format player modifiers holder for SC 
  formatForSC = [];
  
  modKeys.forEach((key, index) => {
    const modName = key.replace("Mod","").toUpperCase();  //ATK
    const modFormatPart = `${modName} Modifier: ${state.playerModifiers[key]}%\n`; //ATK Modifier: 0%

    //Holder to hold all formatted strings
    formatForSC.push(modFormatPart);
  });
  //log(formatForSC);

  // Fetch the "Player Modifiers" card
   const modSC = storyCards.find(sc => sc.title === "Player Modifiers");
  if (!modSC) {
    log('Player Modifiers story card not found!');
    return;
  }

  //Convert holder to string, clean commas, and finally store to sc entry
  modSC.entry = String(formatForSC).replace(/,/g, '');

  // Trim notes on char limit to prevent memory overfill
  if (modSC.description.length > 3000) {
    halfIndex = Math.floor(modSC.description.length / 2);
    modSC.description = modSC.description.slice(0, halfIndex);

    console.log("Trimming modSC description to prevent memory overload.");
  }
}

//RETRIEVE data from sc and store to playerModifiers
function retrieveModifiersFromSC(){
  // Fetch the "Player Modifiers" card
 const modSC = storyCards.find(sc => sc.title === "Player Modifiers");
  if (!modSC) {
    log('Player Modifiers story card not found!');
    return;
  }
  // Retrieve and split sc entry into (modName, value) lines
  const modEntries = modSC.entry.split("\n"); //arr of strings

  //Loop through each line of entry from the split and extract values
  modEntries.forEach(entry => {
      // Match and extract stat and max stat values using regex
      const match = entry.trim().match(/^([A-Z]+)\s+Modifier:\s*(-?\d+(?:\.\d+)?)(?:%)?$/);
      //log("mod sc match: " + match);

      //Store value in holder
      if (match) {
        modName = match[1].toLowerCase() + 'Mod'; // e.g., "HP"
        modValue = Number(match[2]); // e.g., 0

        // Finally store modValue in playerModifier
        //OR operator safeguards against null values    
        state.playerModifiers[modName] = modValue ?? state.playerModifiers[modName];
        
      }
  });

  //log(state.playerModifiers);
}

/////////////////////////////////////////////////////////////////////////////////////

//Initialize player stats
state.playerStats = state.playerStats || {
  lvl: 0,
  exp: 0,
  hp: 0,
  cp: 0,
  ep: 0,
  atk: 0,
  ratk: 0,
  def: 0,
  spd: 0,
  lck: 0,
  intl: 0,
  
  maxLvl: 0,
  maxExp: 0,
  maxHp: 0,
  maxCp: 0,
  maxEp: 0,
  maxAtk: 0,
  maxRatk: 0,
  maxDef: 0,
  maxSpd: 0,
  maxLck: 0,
  maxIntl: 0
};

maxStatKeys = ["maxLvl", "maxExp", "maxHp", "maxCp", "maxEp", "maxAtk", "maxRatk", "maxDef", "maxSpd", "maxLck", "maxIntl"];
statKeys = ["lvl", "exp", "hp", "cp","ep", "atk", "ratk", "def", "spd", "lck", "intl"];


//NOTE: Players stats will be stored in a sc. CREATE initial stats. RETRIEVE from or STORE to player stats: SC -> <- state.playerstats

//Function to create new random player stats
function newPlayerStats(){  
  //Get a random max level
  state.playerStats.maxLvl = randomInt(2,30);

  //Loop through each maxstat, and set max stats equal to max level
  maxStatKeys.forEach((mStat) => {
    state.playerStats[mStat] = state.playerStats.maxLvl;
  });
  
  //Give player random initialized stats capped by max level
  statKeys.forEach((stat) => {
    state.playerStats[stat] = randomInt(1,state.playerStats.maxLvl);
  });

  // EXP starts at 0 and caps at 100
  state.playerStats.exp = 0;
  state.playerStats.maxExp = 100;
  
  // Stat scaling
  state.playerStats.maxHp = state.playerStats.maxLvl * 2 + 20;
  state.playerStats.maxEp = state.playerStats.maxLvl * 2 + 80;
  state.playerStats.maxCp = (state.playerStats.maxLvl * 1.5) + (state.playerStats.intl * 2) + 80;

  // Player starts at full health
  state.playerStats.hp = state.playerStats.maxHp;
  state.playerStats.ep = state.playerStats.maxEp;
  

}

//CREATE new sc with random playerstats if sc doesnt exist
function createIfNoStatSC(){
  if (!storyCards.find(sc => sc.title === "Player Stats")) {
    // If "Player Stats" card doesn't exist, create it
    addStoryCard("Player Stats", "Blank", "Player Stats");

    // Fetch the "Player Stats" card
    const statSC = storyCards.find(sc => sc.title === "Player Stats");
    statSC.description = "Format for Modifying: Stat: num/maxNum";

    //Initialize and randomize new player stats
    newPlayerStats();

    storeStatsToSC();
  }
}

// STORES and displays the stats to player in sc
function storeStatsToSC(){
  // Format player stats holder for SC 
  formatForSC = [];
  
  maxStatKeys.forEach((key, index) => {
    // Lvl storing exception
    if (key == "maxLvl") {
      statFormatPart = `LVL ${state.playerStats.maxLvl}\n`
    }
    else {
      // Remove 'max' and capitalize. Ex: maxAtk -> ATK
      statName = key.substring(3).toUpperCase();

      // Formatted stat line. Ex: ATK: atk/maxAtk
      statFormatPart = `${statName}: ${state.playerStats[statName.toLowerCase()]}/${state.playerStats[key]}\n`;
    }

    // Push to holder for holding all formatted strings
    formatForSC.push(statFormatPart);
  });
  //log(formatForSC);

  // Fetch the "Player Stats" card
  const statSC = storyCards.find(sc => sc.title === "Player Stats");
  if (!statSC) {
    log('Player Stats story card not found!');
    return;
  }

  // Convert holder to string, clean commas, and finally store to sc entry
  statSC.entry = String(formatForSC).replace(/,/g, '');

  // Trim notes on char limit to prevent memory overfill
  if (statSC.description.length > 3000) {
    halfIndex = Math.floor(statSC.description.length / 2);
    statSC.description = statSC.description.slice(0, halfIndex);

    console.log("Trimming statSC description to prevent memory overload.");
  }
}

// RETRIEVE data from sc and store to playerstats
function retrieveStatsFromSC(){
  const statMappings = {
    //lvl: 'maxLvl',
    exp: 'maxExp',
    hp: 'maxHp',
    cp: 'maxCp',
    ep: 'maxEp',
    atk: 'maxAtk',
    ratk: 'maxRatk',
    def: 'maxDef',
    spd: 'maxSpd',
    lck: 'maxLck',
    intl: 'maxIntl',
  };
  
  //Fetch SC
  const statSC = storyCards.find(sc => sc.title === "Player Stats");
  if (!statSC) {
    log('Player Stats story card not found!');
    return;
  }

  // Retrieve and split sc entry into array of stat lines
  const statEntries = statSC.entry.split("\n"); //arr of strings

  // Loop through each stat line in array and extract values
  statEntries.forEach(entry => {
    // Lvl retrieval exception
    const lvlMatch = entry.trim().match(/^(?:LVL|LEVEL)\s*[:\-]?\s*(\d+)$/i);
    if (lvlMatch) {
      state.playerStats.maxLvl = Number(lvlMatch[1]);
      return; // Skip lvl match when found
    }
    
    // Match and extract (statname, stat, maxStat)
    const match = entry.trim().match(/^([a-zA-Z]+)\s*:\s*(\d+(?:\.\d+)?)\s*\/\s*(\d+(?:\.\d+)?)$/);
    //log("stat sc match: " + match);

    //Store value in holder
    if (match) {
      const statName = match[1].toLowerCase();  // stat name (Ex: 'atk')
      const statValue = Number(match[2]);    // current stat value (Ex: '50')
      const maxStatValue = Number(match[3]); // max stat value (Ex: '100')

      // Finally store stat and max stat in the playerStats if name is valid
      if (statMappings[statName]) { //Ex: statMappings[atk] = 'maxAtk'
        //OR operator safeguards against null values    
        state.playerStats[statName] = statValue ?? state.playerStats[statName];
        state.playerStats[statMappings[statName]] = maxStatValue ?? state.playerStats[statMappings[statName]];
      }
    }
  });

  //log(state.playerStats);
}

// Function to increment the player's stats
function statUp(statName,incAmt){
  // Ensure incAmt is a number
  if(typeof incAmt !== "number"){
    incAmt = 0;
  }
  incAmt = Number(incAmt);
  incAmt = Math.round(incAmt * 100) / 100;
  log("incAmt: " + incAmt + " " + statName);

  //Intialize incAmt trackers for logging
  preModIncAmt = incAmt;
  scaledIncAmt = incAmt;

  //Race modifiers influence stat gains
  plrRace = getPlrRace();
  temp = incAmt * state.playerModifiers[statName+'Mod']/100;
  //Multiply temp by negative to ensure modifiers dont modify oppositely when incAmt is negative
  if(incAmt < 0){
    temp = temp * -1;
  }
  incAmt = incAmt + temp;
  incAmt = Math.round(incAmt * 100) / 100;
  preModIncAmt = incAmt;
  scaledIncAmt = incAmt;

  //Race modifiers influence stat gains
  plrRace = getPlrRace();
  temp = incAmt * state.playerModifiers[statName+'Mod']/100;
  //Multiply temp by negative to ensure modifiers dont modify oppositely when incAmt is negative
  if(incAmt < 0){
    temp = temp * -1;
  }
  incAmt = incAmt + temp;
  incAmt = Math.round(incAmt * 100) / 100;
  log("Race modded incAmt: " + incAmt + " " + statName);

  //Get maxstat string key Ex: maxATK
  maxStatName = "max" + statName.charAt(0).toUpperCase() + statName.slice(1);
  
  //Save current stat
  stat = state.playerStats[statName];
  log("stat: " + stat);

  // Exception: Extra hp,cp,ep shouldnt lvl up player, simply increment available value
  if(statName == "hp" || statName == "cp" || statName == "ep"){
    state.playerStats[statName] += incAmt;

    //Only two decimal places
    state.playerStats[statName] = Math.round(state.playerStats[statName] * 100) / 100;

    // Only clamp hp and ep, allow cp (corruption) to exceed max for possession/game over logic
if ((statName === "hp" || statName === "ep") && state.playerStats[statName] > state.playerStats[maxStatName]) {
    state.playerStats[statName] = state.playerStats[maxStatName];
}

// Prevent CP from falling below 0
if (statName === "cp" && state.playerStats.cp < 0) {
    state.playerStats.cp = 0;
}

// --- Game Over if CP exceeds max ---
  if (state.playerStats.cp > state.playerStats.maxCp) {
  state.gameOver = true;
  }
  
    // Fetch the "Player Stats" card and log stat changes in description
    const statSC = storyCards.find(sc => sc.title === "Player Stats");

    if (incAmt >= 0) { sign = "⬆️" }
    if (incAmt < 0) { sign = "🔻" }

    statSC.description = `Log ${state.turnCount} | ${statName.toUpperCase()} ${sign} :  ${stat} → ${state.playerStats[statName]} (Modded: ${incAmt}, Raw: ${preModIncAmt})\n` + statSC.description;

    state.msgHolder = state.msgHolder + `${statName.toUpperCase()} ${sign} :  ${stat} → ${state.playerStats[statName]}\n`;
  }
  else{
    //Formula which decreases value of exp the higher your level and gets the new stat value after exp gain. (stat + incAmt*PercentReduction)
    //New stat after exp scaling formula
    newStat = stat + incAmt * (1.32 * Math.exp(-0.02 * stat));

    // Get scaled incAmt for logging
    scaledIncAmt = incAmt * (1.32 * Math.exp(-0.02 * stat));
    scaledIncAmt = Math.round(scaledIncAmt*100)/100;
    log("scaledIncAmt: " + scaledIncAmt);

    // Two decimal places only
    newStat = Math.round(newStat * 100) / 100;
    log("newStat: " + newStat);
    // todo: fix rounding at very high levels
    // Update the player stat to its new stat
    state.playerStats[statName] = newStat;

    // Stat cant pass max stat so it overflows, get the overflow if it exists
    overflow = state.playerStats[statName] - state.playerStats[maxStatName];
    overflow = Math.round(overflow * 100) / 100;
    log("overflow: " + overflow);

    // Fix stat to not pass maxstat
    if(state.playerStats[statName] > state.playerStats[maxStatName]){
      state.playerStats[statName] = state.playerStats[maxStatName];
    };

    // Fetch the "Player Stats" card and log stat changes in description
    const statSC = storyCards.find(sc => sc.title === "Player Stats");

    if (incAmt >= 0) { sign = "⬆️" }
    if (incAmt < 0) { sign = "🔻" }

    statSC.description = `Log ${state.turnCount} | ${statName.toUpperCase()} ${sign} :  ${stat} → ${state.playerStats[statName]} (Scaled: ${scaledIncAmt}, Modded: ${incAmt}, Raw: ${preModIncAmt})\n` + statSC.description;

    state.msgHolder = state.msgHolder + `${statName.toUpperCase()} ${sign} :  ${stat} → ${state.playerStats[statName]}\n`;

    //If there is positive stat overflow, pass it to player EXP
    if(overflow > 0){
      // Get current max level
      level = state.playerStats.maxLvl;
      log("level: " + level);

      // Scale overflow and add to EXP (Must scale overflow to account when player is high level but has a low stat which will overflow too much to EXP)
      state.playerStats.exp = state.playerStats.exp + (100 * overflow * (1.32 * Math.exp(-0.02 * level)));

      // Round to two decimal places
      state.playerStats.exp = Math.round(state.playerStats.exp * 100) / 100;
      log("state.playerStats.exp: " + state.playerStats.exp);
      
      //When maxEXP is reached, increment plr level and reset EXP to 0
      if(state.playerStats.exp >= state.playerStats.maxExp){
        // Calculate amt of times to increment LVL based on EXP
        lvlIncrement = Math.floor(state.playerStats.exp/state.playerStats.maxExp);
        log("lvlIncrement: " + lvlIncrement);

        // Calculate leftover EXP
        leftoverExp = 100 * (state.playerStats.exp/state.playerStats.maxExp - lvlIncrement);
        log("leftoverExp: " + leftoverExp);
        
        // Increment LVL
        state.playerStats.maxLvl += lvlIncrement;

        // Reset EXP to 0 and add leftover exp
        state.playerStats.exp = 0 + leftoverExp;
        state.playerStats.exp = Math.round(state.playerStats.exp * 100) / 100;

        // Fetch the "Player Stats" card and leave log in description
        const statSC = storyCards.find(sc => sc.title === "Player Stats");
        statSC.description = `Log ${state.turnCount} | LVL ${level} → ${state.playerStats.maxLvl}\n` + statSC.description;

        state.msgHolder = state.msgHolder + `LVL ${level} → ${state.playerStats.maxLvl}\n`;

        // Since player has leveled up, increase all max stats
        maxStatKeys.forEach((key) => {
          //Get mod key
          statKey = key.slice(3); // Remove "max"
          modName = statKey.toLowerCase() + "Mod";
          
          // Apply max stat changes
          if(key == "maxHp"){
            state.playerStats[key] += 5 + (5 * state.playerModifiers[modName]/100);
          }
          else if(key == "maxEp"){
            state.playerStats[key] += 5 + (5 * state.playerModifiers[modName]/100);
          }
          else if(key == "maxCp"){
            state.playerStats[key] += 5 + state.playerStats.intl * 0.1 + (5 * state.playerModifiers[modName]/100);
          }
          else{
            if(key != 'maxLvl' && key != 'maxExp'){
              state.playerStats[key] += 5  + (5 * state.playerModifiers[modName]/100);;
            }
          }

          //Two decimal places
          state.playerStats[key] = Math.round(state.playerStats[key]*100)/100;
        });

      } // End of level up
    } //end of positive overflow
  }

  storeStatsToSC(); 
}

function playerNaturalRegen(){
  //Player regens only if alive
  if(state.playerStats.hp > 0){
    statUp("hp",1);
    statUp("cp",-2);

    //Player loses available energy only
    if(state.playerStats.ep > 0){
      statUp("ep",-1 * randomFloat(0,1));
    }
  }
 
}

//Edit text to show player health
function warnPlayerHealth(text){
  plrHealth = state.playerStats.hp;
  plrMaxHealth = state.playerStats.maxHp; 
  plrEnergy = state.playerStats.ep;
  plrMaxEnergy = state.playerStats.maxEp;
  numTurnsDisplay = 5;
  
  //warn player every 5 inputs, they have half health
  if((plrHealth/plrMaxHealth) >= 0.45 && (plrHealth/plrMaxHealth) <= 0.50 && state.inputCount % numTurnsDisplay === 0){
    text = text + ` ${realizePhrases[randomInt(0,realizePhrases.length-1)]} ${healthFeelsHalfway[randomInt(0,healthFeelsHalfway.length-1)]}.`;
  }
  //Warns at 1% to 10% health
  else if((plrHealth/plrMaxHealth) >= 0.01 && (plrHealth/plrMaxHealth) <= 0.10 && state.inputCount % numTurnsDisplay === 0){
    text = text + ` ${realizePhrases[randomInt(0,realizePhrases.length-1)]} ${healthVeryLow[randomInt(0,healthVeryLow.length-1)]}.`;
  }

  //Player Death at 0%
  if(plrHealth <= 0 && state.inputCount % 2 === 0){
    text = text + ` Suddenly, ${healthDeathArray[randomInt(0,healthDeathArray.length-1)]} The world continues without you.`;

    state.msgHolder = state.msgHolder + `GAME OVER. You died!\n`;
  }


  //Warns every 5 input, at 50% energy
  if((plrEnergy/plrMaxEnergy) >= 0.45 && (plrEnergy/plrMaxEnergy) <= 0.50 && state.inputCount % numTurnsDisplay === 0){
    text = text + ` ${realizePhrases[randomInt(0,realizePhrases.length-1)]} ${halfEnergyArray[randomInt(0,halfEnergyArray.length-1)]}`;
  }
  //Warns at 1% to 10% energy
  else if((plrEnergy/plrMaxEnergy) >= 0.01 && (plrEnergy/plrMaxEnergy) <= 0.10 && state.inputCount % numTurnsDisplay === 0){
    text = text + ` ${realizePhrases[randomInt(0,realizePhrases.length-1)]} ${exhaustedArray[randomInt(0,exhaustedArray.length-1)]}`;

    state.msgHolder = state.msgHolder + `Your energy is very low. You may want to rest or eat.\n`

  }
  
  //No energy at 0%
  if(plrEnergy <= 0 && state.inputCount % 5 === 0){
    text = text + ` Suddenly, ${exhaustionSleepArray[randomInt(0,exhaustionSleepArray.length-1)]}`; 

    state.msgHolder = state.msgHolder + `You have no energy! Recover by consuming or sleeping.\n`
  }

  return text;
}

//create a Player Injuries story card if it doesn't exist
function createIfNoInjurySC() {
  if (!storyCards.find(sc => sc.title === "Player Injuries")) {
    addStoryCard("Player Injuries", "Tracks all current injuries.", "Player Stats");
    let injSC = storyCards.find(sc => sc.title === "Player Injuries");
    injSC.description = "Each line: [Turn] | [Severity] | [Body Part] | [Description]";
    injSC.entry = "";
  }
}

// Adds a new injury to the Player Injuries story card
function storeInjuryToSC(severity, bodyPart, description) {
  createIfNoInjurySC();
  let injSC = storyCards.find(sc => sc.title === "Player Injuries");
  let turn = state.turnCount || 0;
  let line = `Turn ${turn} | ${severity} | ${bodyPart} | ${description}`;
  injSC.entry = line + "\n" + (injSC.entry || "");
}
//////////////////////////////////////////WEAPONS///////////////////////////////////////////

//Initialize weapon modifiers
state.weaponModifiers = state.weaponModifiers || {
  ammoMod: 0,
  condMod: 0,
};

weaponmodKeys = ["ammoMod", "condMod"];
weaponStatKeysForMod = ["ammo", "cond"];

// CREATE new sc with Weapon Modifiers if sc doesn't exist
function createIfNoWeaponmodSC() {
  if (!storyCards.find(sc => sc.title === "Weapon Modifiers")) {
    addStoryCard("Weapon Modifiers", "Blank", "Weapons");
    const weaponmodSC = storyCards.find(sc => sc.title === "Weapon Modifiers");
    weaponmodSC.description = `Format for Modifying: Modifier: num\nModifiers influence your weapon stats and modify the exp you receive.`;
    weaponmodKeys.forEach(key => {
      state.weaponModifiers[key] = 0;
    });
    storeWeaponmodsToSC();
  }
}

// STORES and displays the modifiers to weapons in sc
function storeWeaponmodsToSC() {
  let formatForSC = [];
  weaponmodKeys.forEach((key) => {
    const weaponmodName = key.replace("Mod", "").toUpperCase();
    formatForSC.push(`${weaponmodName} Modifier: ${state.weaponModifiers[key]}%\n`);
  });
  const weaponmodSC = storyCards.find(sc => sc.title === "Weapon Modifiers");
  weaponmodSC.entry = formatForSC.join("").replace(/,/g, '');
  if (weaponmodSC.description.length > 3000) {
    let halfIndex = Math.floor(weaponmodSC.description.length / 2);
    weaponmodSC.description = weaponmodSC.description.slice(0, halfIndex);
    console.log("Trimming weaponmodSC description to prevent memory overload.");
  }
}

// RETRIEVE data from sc and store to Weapon Modifiers
function retrieveWeaponmodsFromSC() {
  const weaponmodSC = storyCards.find(sc => sc.title === "Weapon Modifiers");
  const weaponmodEntries = weaponmodSC.entry.split("\n");
  weaponmodEntries.forEach(entry => {
    const match = entry.trim().match(/^([A-Z]+)\s+Modifier:\s*(-?\d+(?:\.\d+)?)(?:%)?$/);
    if (match) {
      let weaponmodName = match[1].toLowerCase() + 'Mod';
      let weaponmodValue = Number(match[2]);
      state.weaponModifiers[weaponmodName] = weaponmodValue ?? state.weaponModifiers[weaponmodName];
    }
  });
}

// CREATE new story card for equipped weapon in "Equipped Gear" category if it doesn't exist
function createIfNoEquippedWeaponSC() {
  if (!storyCards.find(sc => sc.title === "Equipped Weapon")) {
    addStoryCard("Equipped Weapon", "Currently equipped weapon.", "Equipped Gear");
    // Optionally, set a description for the card
    let eqSC = storyCards.find(sc => sc.title === "Equipped Weapon");
    eqSC.description = "Stores the name of your currently equipped weapon. Format: Weapon Name";
    eqSC.entry = ""; // Start empty
  }
}

// Store equipped weapon in the "Equipped Gear" category
function storeEquippedWeaponToSC(weaponName) {
  createIfNoEquippedWeaponSC();
  let eqSC = storyCards.find(sc => sc.title === "Equipped Weapon");
  eqSC.entry = weaponName || "";
}

// Retrieve equipped weapon from the "Equipped Gear" category
function retrieveEquippedWeaponFromSC() {
  let eqSC = storyCards.find(sc => sc.title === "Equipped Weapon");
  return eqSC && eqSC.entry ? eqSC.entry : null;
}


// Initialize Weapon stats for currently equipped weapon
function getCurrentWeaponName() {
  // Use state.equippedWeapon if set, else default to first weapon card
  if (state.equippedWeapon) return state.equippedWeapon;
  const weaponCard = storyCards.find(sc => sc.type === "Weapons" || sc.category === "Weapons");
  return weaponCard ? weaponCard.title : null;
}

// CREATE new sc with weaponstats if sc doesn't exist
function createIfNoWeaponSC() {
  // Only create starter weapons if NO weapon cards exist
  if (!storyCards.some(sc => sc.type === "Weapons" || sc.category === "Weapons")) {
    // Laspistol
    addStoryCard("Laspistol", "A simple starter weapon.", "Weapons");
    const laspistolSC = storyCards.find(sc => sc.title === "Laspistol");
    laspistolSC.description = "Format for Modifying: Stat: num/maxNum";
    laspistolSC.entry =
      "Laspistol\n" +
      "COND: 100/100\n" +
      "AMMO: 20/20\n" +
      "DMG TYPE: Laser Class 1\n" +
      "AMMO ITEM: micro cell\n" +
      "Laspistol\n" +
      "The Laspistol is a compact sidearm favored for its reliability and ease of use. Effective at close range.\n";

    // Lasrifle 
    addStoryCard("Lasrifle", "A standard-issue rifle with burst fire capability.", "Weapons");
    const lasrifleSC = storyCards.find(sc => sc.title === "Lasrifle");
    lasrifleSC.description = "Format for Modifying: Stat: num/maxNum";
    lasrifleSC.entry =
      "Lasrifle\n" +
      "COND: 100/100\n" +
      "AMMO: 50/50\n" +
      "DMG TYPE: Laser Class 2\n" +
      "AMMO ITEM: power cell\n" +
      "Burst Fire Mode: OFF\n" +
      "Lasrifle\n" +
      "The Lasrifle is a standard-issue rifle, reliable, rugged and versatile for most combat situations.\n";

    // RS-43 Longstrike
    addStoryCard("RS-43 Longstrike", "A powerful rifle with overcharge capability for increased damage.", "Weapons");
    const longstrikeSC = storyCards.find(sc => sc.title === "RS-43 Longstrike");
    longstrikeSC.description = "Format for Modifying: Stat: num/maxNum";
    longstrikeSC.entry =
      "RS-43 Longstrike\n" +
      "COND: 100/100\n" +
      "AMMO: 20/20\n" +
      "DMG TYPE: Laser Class 3\n" +
      "AMMO ITEM: power cell\n" +
      "Overcharge Mode: OFF\n" +
      "RS-43 Longstrike\n" +
      "The RS-43 Longstrike is a powerful long-range rifle with overcharge capability for greatly increased damage at the cost of full power cell consumption.\n";

    // Vibro Blade
    addStoryCard("Vibro Blade", "A deadly vibrating blade with microscopic serrations.", "Weapons");
    const vibroBladeSC = storyCards.find(sc => sc.title === "Vibro Blade");
    vibroBladeSC.description = "Format for Modifying: Stat: num/maxNum";
    vibroBladeSC.entry =
      "Vibro Blade\n" +
      "COND: 100/100\n" +
      "CHARGE: 100/100\n" +
      "DMG TYPE: Vibration/Cutting\n" +
      "CHARGE ITEM: power cell\n" +
      "Vibro Blade\n" +
      "The Vibro Blade is a fearsome melee weapon with microscopic serrated edges that vibrate at ultrasonic frequencies. When activated, it can slice through armor and flesh with terrifying efficiency, creating a distinctive humming sound. Standard issue for close-quarters combat specialists.";
  }
}


// STORES and displays weapon stats in sc
function storeWeaponToSC(weaponName, weaponStatsOverride) {
  weaponName = weaponName || getCurrentWeaponName();
  if (!weaponName) return;
  const weaponSC = storyCards.find(sc => sc.title.toLowerCase() === weaponName.toLowerCase());
  if (!weaponSC) {
    log(`Weapon story card not found for: ${weaponName}`);
    return;
  }
  let stats = weaponStatsOverride || retrieveWeaponStatsFromEntry(weaponSC.entry);

  // Split the original entry into lines
  let lines = weaponSC.entry.split('\n');
  let newLines = [];
  let used = {
    cond: false,
    ammo: false,
    dmg: false,
    ammoItem: false,
    burst: false,
    overcharge: false
  };

  // Replace or update stat lines, preserve others (flavor text, etc.)
  for (let line of lines) {
    if (/^COND:/i.test(line)) {
      newLines.push(`COND: ${stats.cond}/${stats.maxCond}`);
      used.cond = true;
    } else if (/^AMMO:/i.test(line)) {
      newLines.push(`AMMO: ${stats.ammo}/${stats.maxAmmo}`);
      used.ammo = true;
    } else if (/^DMG TYPE:/i.test(line)) {
      newLines.push(`DMG TYPE: ${stats.dmgType || "Laser"}`);
      used.dmg = true;
    } else if (/^AMMO ITEM:/i.test(line)) {
      newLines.push(`AMMO ITEM: ${stats.ammoItem || ""}`);
      used.ammoItem = true;
    } else if (/^Burst Fire Mode:/i.test(line)) {
        newLines.push(`Burst Fire Mode: ${stats.burstFireMode ? "ON" : "OFF"}`);
        used.burst = true;
    } else if (/^Overcharge Mode:/i.test(line)) {
      newLines.push(`Overcharge Mode: ${stats.overchargeMode ? "ON" : "OFF"}`);
      used.overcharge = true;
    } else {
      newLines.push(line);
    }
  }

  // Only add missing stat lines if they were present in the original entry
  // Insert in correct order: COND, AMMO, DMG TYPE, AMMO ITEM, [Burst/Overcharge], [other]
  function insertAfter(label, value) {
    let idx = newLines.findIndex(l => new RegExp(`^${label}:`, "i").test(l));
    if (idx !== -1) {
      newLines.splice(idx + 1, 0, value);
    }
  }
  // Add missing lines in correct order if they existed in original
  if (!used.cond && lines.some(l => /^COND:/i.test(l)))
    newLines.unshift(`COND: ${stats.cond}/${stats.maxCond}`);
  if (!used.ammo && lines.some(l => /^AMMO:/i.test(l)))
    insertAfter("COND", `AMMO: ${stats.ammo}/${stats.maxAmmo}`);
  if (!used.dmg && lines.some(l => /^DMG TYPE:/i.test(l)))
    insertAfter("AMMO", `DMG TYPE: ${stats.dmgType || "Laser"}`);
  if (!used.ammoItem && lines.some(l => /^AMMO ITEM:/i.test(l)))
    insertAfter("DMG TYPE", `AMMO ITEM: ${stats.ammoItem || ""}`);
  if (!used.burst && lines.some(l => /^Burst Fire Mode:/i.test(l)))
    insertAfter("AMMO ITEM", `Burst Fire Mode: ${stats.burstFireMode ? "ON" : "OFF"}`);
  if (!used.overcharge && lines.some(l => /^Overcharge Mode:/i.test(l)))
    insertAfter("AMMO ITEM", `Overcharge Mode: ${stats.overchargeMode ? "ON" : "OFF"}`);

  weaponSC.entry = newLines.join('\n').replace(/^\n+|\n+$/g, '');
  if (weaponSC.description.length > 3000) {
    let halfIndex = Math.floor(weaponSC.description.length / 2);
    weaponSC.description = weaponSC.description.slice(0, halfIndex);
    console.log("Trimming weaponSC description to prevent memory overload.");
  }
}


// Helper: Parse weapon stats from entry string
function retrieveWeaponStatsFromEntry(entry) {
  let stats = { cond: 100, ammo: 50, maxCond: 100, maxAmmo: 50, burstFireMode: false, overchargeMode: false, dmgType: "Laser" };
  entry.split("\n").forEach(line => {
    let match = line.match(/^COND:\s*(\d+)\s*\/\s*(\d+)/i);
    if (match) {
      stats.cond = Number(match[1]);
      stats.maxCond = Number(match[2]);
    }
    match = line.match(/^AMMO:\s*(\d+)\s*\/\s*(\d+)/i);
    if (match) {
      stats.ammo = Number(match[1]);
      stats.maxAmmo = Number(match[2]);
    }
    match = line.match(/^DMG TYPE:\s*(.+)$/i);
    if (match) {
      stats.dmgType = match[1].trim();
    }
    match = line.match(/^AMMO ITEM:\s*(.+)$/i);
    if (match) {
      stats.ammoItem = match[1].trim();
    }
    match = line.match(/^Burst Fire Mode:\s*(ON|OFF)$/i);
    if (match) {
      stats.burstFireMode = match[1].toUpperCase() === "ON";
    }
    match = line.match(/^Overcharge Mode:\s*(ON|OFF)$/i);
    if (match) {
      stats.overchargeMode = match[1].toUpperCase() === "ON";
    }
  });
  return stats;
}

// RETRIEVE data from sc and store to weapon
function retrieveWeaponFromSC(weaponName) {
  weaponName = weaponName || getCurrentWeaponName();
  if (!weaponName) return;
   const weaponSC = storyCards.find(sc => sc.title.toLowerCase() === weaponName.toLowerCase());
  if (!weaponSC) {
    log(`Weapon story card not found for: ${weaponName}`);
    return;
  }
  return retrieveWeaponStatsFromEntry(weaponSC.entry);
}

// Helper: Update weapon modes in story card
function updateWeaponModes(weaponName, weaponStats) {
  let weaponSC = storyCards.find(sc => sc.title.toLowerCase() === weaponName.toLowerCase());
  if (!weaponSC) return;

  // Split the entry into lines
  let lines = weaponSC.entry.split('\n');
  let newLines = [];
  let statLabels = [
    { label: "COND:", value: `COND: ${weaponStats.cond}/${weaponStats.maxCond}` },
    { label: "AMMO:", value: `AMMO: ${weaponStats.ammo}/${weaponStats.maxAmmo}` },
    { label: "DMG TYPE:", value: `DMG TYPE: ${weaponStats.dmgType || "Laser"}` },
    { label: "AMMO ITEM:", value: `AMMO ITEM: ${weaponStats.ammoItem || ""}` },
    { label: "Burst Fire Mode:", value: `Burst Fire Mode: ${weaponStats.burstFireMode ? "ON" : "OFF"}` },
    { label: "Overcharge Mode:", value: `Overcharge Mode: ${weaponStats.overchargeMode ? "ON" : "OFF"}` }
  ];

  for (let line of lines) {
    let trimmed = line.trim();
    let replaced = false;
    for (let stat of statLabels) {
      if (trimmed.startsWith(stat.label)) {
        newLines.push(stat.value);
        replaced = true;
        break;
      }
    }
    if (!replaced) newLines.push(line);
  }
  weaponSC.entry = newLines.join('\n').replace(/^\n+|\n+$/g, '');
}

function detectFireModeToggle(text) {
  // Only check if a weapon is equipped
  let weaponName = state.equippedWeapon || retrieveEquippedWeaponFromSC();
  if (!weaponName) return text;

  let weaponStats = retrieveWeaponFromSC(weaponName) || {};

  let changed = false;

  // Normalize input
  let t = text.toLowerCase();

  // Accept more verbs and patterns for toggling burst fire
 if (
  /(toggle|select|switch|flip|set|change|turn|enable|disable).{0,30}(burst\s*fire|burst)/i.test(t) ||
  /(burst\s*fire|burst).{0,30}(mode|on|off|enabled|disabled)/i.test(t) ||
  /(to|into)\s+burst\s*fire/i.test(t) ||
  /selector.*(to|for|into)\s*burst\s*fire/i.test(t) ||
  /flip.*selector.*burst\s*fire/i.test(t)
) {
  weaponStats.burstFireMode = !weaponStats.burstFireMode;
  updateWeaponModes(weaponName, weaponStats);
  storeWeaponToSC(weaponName, weaponStats);
  state.msgHolder += `Burst Fire Mode is now ${weaponStats.burstFireMode ? "ON" : "OFF"} for your ${weaponName}.\n`;
  changed = true;
}

  // Accept more verbs and patterns for toggling overcharge
  if (
    /(toggle|select|switch|flip|set|change|turn|enable|disable).{0,15}(overcharge)/i.test(t) ||
    /(overcharge).{0,15}(mode|on|off|enabled|disabled)/i.test(t) ||
    /(to|into)\s+overcharge/i.test(t)
  ) {
    weaponStats.overchargeMode = !weaponStats.overchargeMode;
    updateWeaponModes(weaponName, weaponStats);
    storeWeaponToSC(weaponName, weaponStats);
    state.msgHolder += `Overcharge Mode is now ${weaponStats.overchargeMode ? "ON" : "OFF"} for your ${weaponName}.\n`;
    changed = true;
  }

  if (changed) return text + " [Fire mode toggled]";
  return text;
}

function detectAttack(text) {
  return detectCombatAction(text, attackWords, 'attack');
}
function detectRangedattack(text) {
  return detectCombatAction(text, rangedattackWords, 'ranged');
}


// --- Patch statUpWeapon to use updateWeaponModes and preserve all lines ---
function statUpWeapon(statName, incAmt, weaponName) {
  weaponName = weaponName || getCurrentWeaponName();
  if (!weaponName) return;
  const weaponSC = storyCards.find(sc => sc.title.toLowerCase() === weaponName.toLowerCase());
  if (!weaponSC) return;
  let stats = retrieveWeaponStatsFromEntry(weaponSC.entry);
  incAmt = Number(incAmt) || 0;
  let maxStatName = "max" + statName.charAt(0).toUpperCase() + statName.slice(1);
  let prev = stats[statName];
  stats[statName] += incAmt;
  if (stats[statName] > stats[maxStatName]) stats[statName] = stats[maxStatName];
  if (stats[statName] < 0) stats[statName] = 0;
  // Log stat change in weapon story card
  let sign = incAmt >= 0 ? "⬆️" : "🔻";
  weaponSC.description = `Log ${state.turnCount} | ${statName.toUpperCase()} ${sign} : ${prev} → ${stats[statName]} (Change: ${incAmt})\n` + weaponSC.description;
  // Use the improved update function to preserve all lines
  updateWeaponModes(weaponName, stats);
}

////////////////////////////////Inventory Management/////////////////////////////////////////////////////

// Initialize player inventory
state.playerInv = state.playerInv || {
  item: [],
  amt: []
};
console.log("Player Inventory: " + state.playerInv.item + "\n" + state.playerInv.amt);

// CREATE new sc with player inv if sc doesnt exist
function createIfNoInvSC(){
  if (!storyCards.find(sc => sc.title === "Player Inventory")) {
    // If "Player Inventory" card doesn't exist, create it
    addStoryCard("Player Inventory", "Blank", "Player Stats");

    // Fetch the "Player Inventory" card
    const invSC = storyCards.find(sc => sc.title === "Player Inventory");
    invSC.description = "Format for Modifying: ItemName (amt: X)";

  }
}

// STORE inv to sc
function storeInvToSC(){
  // Fetch the "Player Inventory" card
  const invSC = storyCards.find(sc => sc.title === "Player Inventory");
  if (!invSC) {
    log('Player Inventory story card not found!');
    return;
  }
  // Format and display to sc
  invSC.entry = state.playerInv.item.map((item, index) => `${item} (Amt: ${state.playerInv.amt[index]})`).join("\n");

  // Trim notes on char limit to prevent memory overfill
  if (invSC.description.length > 3000) {
    halfIndex = Math.floor(invSC.description.length / 2);
    invSC.description = invSC.description.slice(0, halfIndex);

    console.log("Trimming invSC description to prevent memory overload.");
  }
}

// RETRIEVE inv data from sc
function retrieveInvFromSC(){
  // Fetch the "Player Inventory" card
  const invSC = storyCards.find(sc => sc.title === "Player Inventory");
  if (!invSC) {
    log('Player Inventory story card not found!');
    return;
  }
  // Get inv sc entry
  fromInvSC = invSC.entry;
  log("fromInvSC: " + fromInvSC);

  // Use regex to extract item names and amounts (Ex: Ball (Amt: 2), etc. )
  matches = fromInvSC.matchAll(/(.+?)\s*\(Amt:\s*(\d+(?:\.\d+)?)\)/gi);

  itemHold = [];
  amtHold = [];
  for (const match of matches) {
    itemHold.push(match[1].trim()); // Extract item name to holder
    amtHold.push(Number(match[2])); // Extract amount as integer to holder2
  }

  // Store retrieved data to codebase 
  state.playerInv.item = itemHold;
  state.playerInv.amt = amtHold;
  //console.log("Items:", state.playerInv.item);
  //console.log("Amounts:", state.playerInv.amt);
}


function detectStoreInv(text) {

  // Prevent inventory actions during dialogue
 if (isPlayerDialoguing(text)) return text; // Skip inventory logic if dialoguing

 // First, check if this is actually a combat action
  if (/take\s+aim|aim\s+at|and\s+fire|you\s+fire|fire\s+at/i.test(text.toLowerCase())) {
    return text; // This is likely a combat action, not inventory management
  }

    // Remove punctuation except hyphens, split into words
    let wordsArr = text.replace(/[.,!?]/g, '').replace(/\s+/g, ' ').trim().split(' ');

    // Find the index of the first equip/store verb
    let equipIndex = wordsArr.findIndex(w => equipWords.some(eq => w.toLowerCase() === eq.toLowerCase()));
    if (equipIndex === -1) return text;

    // Find the index of the first inventory word (optional)
    let invIndex = wordsArr.findIndex(w => invWords.some(inv => w.toLowerCase() === inv.toLowerCase()));

    // Extract everything after the equip verb up to the inventory word (or end)
    let afterEquip = wordsArr.slice(equipIndex + 1, invIndex !== -1 ? invIndex : undefined).join(' ');

    // Split on " and " to get possible item phrases
    let itemPhrases = afterEquip.split(/\s+and\s+/i).map(s => s.trim()).filter(Boolean);

    // Regex to remove trailing location phrases (expand as needed)
    const trailingLocationRegex = /\s*(from|off|on|in|out of|near|by|at|into|onto|upon|beside|under|over|behind|before|after)\s+(the\s+)?[\w\s\-']+$/i;

    let addedAny = false;
    for (let phrase of itemPhrases) {
        // Remove trailing location/prepositional phrase using regex
        let cleanPhrase = phrase.replace(trailingLocationRegex, '').trim();

        // Remove stopwords, equip/inventory words, and trailing verbs/prepositions
        let itemWords = cleanPhrase.split(' ').filter(w =>
            !equipWords.includes(w.toLowerCase()) &&
            !invWords.includes(w.toLowerCase()) &&
            !stopWords.includes(w.toLowerCase())
        );
        while (itemWords.length > 1 && /(placing|putting|adding|storing|taking|grabbing|equipping|looting|snatching|it|them|this|that)/i.test(itemWords[itemWords.length - 1])) {
            itemWords.pop();
        }

        // Now check if the first word is a number or number word
        let itemAmt = 1;
        const numberWordsRegex = /^(zero|one|two|three|four|five|six|seven|eight|nine|ten|eleven|twelve|thirteen|fourteen|fifteen|sixteen|seventeen|eighteen|nineteen|twenty|thirty|forty|fifty|sixty|seventy|eighty|ninety|hundred|thousand)$/i;
        if (itemWords.length > 1 && numberWordsRegex.test(itemWords[0])) {
            itemAmt = parseInt(wordsToNumber(itemWords[0]).trim());
            itemWords = itemWords.slice(1);
        } else if (itemWords.length > 1 && /^\d+$/.test(itemWords[0])) {
            itemAmt = parseInt(itemWords[0]);
            itemWords = itemWords.slice(1);
        }

        // Singularize last word if it's a simple plural (e.g., "cells" -> "cell"), but keep hyphens
        if (
            itemWords.length > 0 &&
            /s$/.test(itemWords[itemWords.length - 1]) &&
            !/ss$/.test(itemWords[itemWords.length - 1])
        ) {
            itemWords[itemWords.length - 1] = itemWords[itemWords.length - 1].replace(/s$/, '');
        }

        // Join remaining words as item name (hyphens are preserved)
        let itemName = itemWords.join(' ').trim();

        // Final sanity checks
        if (!itemName || itemName.length < 2) continue;

        // --- Regex: Ignore environmental/non-item phrases ---
        if (debugNonItemMatch(itemName)) {
            state.msgHolder += `Ignored non-item phrase: "${itemName}"\n`;
            continue;
        }

        // Add to inventory (merge with existing if present)
        let alreadyIndex = state.playerInv.item.findIndex(i => i.toLowerCase() === itemName.toLowerCase());
        if (alreadyIndex !== -1 && state.playerInv.amt[alreadyIndex] !== undefined) {
           state.playerInv.amt[alreadyIndex] += itemAmt;
        } else {
        state.playerInv.item.push(itemName);
        state.playerInv.amt.push(itemAmt);
        } 
        state.msgHolder += `🎒 +${itemAmt} ${itemName}\n`;
        addedAny = true;

        // --- Auto-equip weapon if none equipped ---
        let weaponNames = getWeaponNamesFromStoryCards();
        let equippedWeapon = state.equippedWeapon || retrieveEquippedWeaponFromSC();
        if (
            weaponNames.some(w => itemName.toLowerCase().includes(w) || w.includes(itemName.toLowerCase())) &&
            !equippedWeapon
        ) {
            storeEquippedWeaponToSC(itemName);
            state.equippedWeapon = itemName;
            state.msgHolder += `You equip the ${itemName}.\n`;
        }
    }

    if (addedAny) storeInvToSC();

    return addedAny ? text + "🎒" : text;
}

// Detects when items are removed, dropped, thrown, or taken from the player inventory
function detectRemoveFromInv(text) {
  // Define verbs that indicate removal
  const removeWords = [
    "drop", "discard", "throw", "toss", "lose", "remove", "give", "hand", "donate", "leave", "abandon", "release", "shed", "let go", "throw away", "throw out", "get rid of", "pass", "offer", "surrender", "yield", "forfeit", "deliver", "send", "transfer", "take away", "taken", "stolen", "robbed"
  ];

  // Normalize input
  let t = text.toLowerCase();

  // Check if any remove word is present
  let found = removeWords.some(word => t.includes(word));
  if (!found) return text;

  // Try to find which item is being removed
  let itemRemoved = null;
  let amtRemoved = 1;
  
  // Get currently equipped weapon for comparison
  let equippedWeapon = state.equippedWeapon || retrieveEquippedWeaponFromSC();

  // Try to match an item from inventory
  for (let i = 0; i < state.playerInv.item.length; i++) {
    let itemName = state.playerInv.item[i].toLowerCase();
    if (t.includes(itemName)) {
        if (i < state.playerInv.amt.length && state.playerInv.amt[i] !== undefined) {
            itemRemoved = state.playerInv.item[i];
            
            // Try to detect amount (e.g., "drop 2 apples")
            let regex = new RegExp(`(?:drop|discard|throw|toss|remove|give|hand|leave|abandon|release|shed|let go|throw away|throw out|get rid of|pass|offer|surrender|yield|forfeit|deliver|send|transfer|take away|taken|stolen|robbed)\\s+(\\d+)\\s+${itemName}`, "i");
            let match = text.match(regex);
            if (match && match[1]) {
                amtRemoved = parseInt(match[1]);
            }
            
            // --- Bounds check: never remove more than you have ---
            amtRemoved = Math.max(1, Math.min(amtRemoved, state.playerInv.amt[i]));
            state.playerInv.amt[i] -= amtRemoved;
            
            // Check if this is the equipped weapon and we're removing all of it
            if (equippedWeapon && equippedWeapon.toLowerCase() === itemName && 
                (state.playerInv.amt[i] <= 0 || amtRemoved === state.playerInv.amt[i])) {
                storeEquippedWeaponToSC(""); // Clear the equipped weapon
                state.equippedWeapon = null; // Also clear the state variable
                state.msgHolder += `You no longer have ${itemRemoved} equipped.\n`;
            }
            
            // Remove item completely if amount is 0
            if (state.playerInv.amt[i] <= 0) {
                state.playerInv.item.splice(i, 1);
                state.playerInv.amt.splice(i, 1);
            }
            
            storeInvToSC();
            state.msgHolder += `🗑️ -${amtRemoved} ${itemRemoved}\n`;
            break;
        }
    }
  }
  return text;
}

///////Reload Weapon function

// Add this function anywhere after your utility functions

function detectReload(text) {
  // Normalize input
  let t = text.toLowerCase();

  // Accept common reload commands
  if (!/(reload|change\s+mag|swap\s+magazine|insert\s+ammo|load\s+ammo)/i.test(t)) return text;

  // Get equipped weapon
  let weaponName = state.equippedWeapon || retrieveEquippedWeaponFromSC();
  if (!weaponName) {
    state.msgHolder += "You have no weapon equipped to reload.\n";
    return text + " You have no weapon equipped to reload.";
  }

  // Get weapon stats and SC
  let weaponSC = storyCards.find(sc => sc.title.toLowerCase() === weaponName.toLowerCase());
  if (!weaponSC) return text;
  let weaponStats = retrieveWeaponStatsFromEntry(weaponSC.entry);

  // Determine ammo item name (e.g., "lasrifle cell" for "lasrifle")
  let ammoItem = weaponStats.ammoItem || (weaponName.toLowerCase() + " cell");

  // Check inventory for ammo
  let invIndex = state.playerInv.item.findIndex(i => i.toLowerCase() === ammoItem);
  if (invIndex === -1 || state.playerInv.amt[invIndex] < 1) {
    state.msgHolder += `You have no ${ammoItem}s in your inventory to reload.\n`;
    return text + ` You have no ${ammoItem}s to reload.`;
  }

  // Only reload if not already full
  if (weaponStats.ammo >= weaponStats.maxAmmo) {
    state.msgHolder += `Your ${weaponName} is already fully loaded.\n`;
    return text + ` Your ${weaponName} is already fully loaded.`;
  }

  // Set ammo to max and remove one ammo item from inventory
  weaponStats.ammo = weaponStats.maxAmmo;
  state.playerInv.amt[invIndex] -= 1;
  if (state.playerInv.amt[invIndex] <= 0) {
    state.playerInv.item.splice(invIndex, 1);
    state.playerInv.amt.splice(invIndex, 1);
  }
  storeWeaponToSC(weaponName, weaponStats);
  storeInvToSC();

  state.msgHolder += `You reload your ${weaponName} using a ${ammoItem} ⚙️.\n`;
  return text + ` You reload your ${weaponName} ⚙️.`;
}



///Player skills will be stored in an sc. CREATE initial sc. Skills will STORE TO or RETREIVE FROM sc.

// Initialize player skills (ensure always defined for stateless AI Dungeon)

state.playerSkills = state.playerSkills || {
  name: [],
  lvl: [],
  cost: []
};

//Function to create new class skills for player and store to their skills
function newClassSkills(classString,skillArray){
  plotEssentials = state.memory.context.toLowerCase();
  if(plotEssentials.includes(classString + " class")){
    state.playerSkills.name = [
      skillArray[randomInt(0,skillArray.length-1)],skillArray[randomInt(0,skillArray.length-1)],skillArray[randomInt(0,skillArray.length-1)]
    ];
    state.playerSkills.lvl = [
      randomInt(0,3),
      randomInt(0,3),
      randomInt(0,3)
    ];
    state.playerSkills.cost = [
      randomInt(10,40),
      randomInt(10,40),
      randomInt(10,40)
    ];

    storeSkillsToSC();
  }
}

//Always CREATE initial sc if none.
function createIfNoSkillSC() {
  // If "Player Skills" card doesn't exist, create it
  if (!storyCards.find(sc => sc.title === "Player Skills")) {
    addStoryCard("Player Skills", "Blank", "Player Stats");

    // Fetch SC and give it a description
    const skillSC = storyCards.find(sc => sc.title === "Player Skills");
    skillSC.description = "Format for Modifying: SkillName (LVL), etc.";

     // Try to detect class and assign skills
     let assigned = false;
     if (state.memory && state.memory.context) {
      let context = state.memory.context.toLowerCase();
      if (context.includes("psyker class")) {
        newClassSkills('psyker', beginnerPsykerSpells);
        assigned = true;
       } else if (context.includes("medic class")) {
        newClassSkills('medic', beginnerMedicSkills);
        assigned = true;
       } else if (context.includes("tech class")) {
        newClassSkills('tech', beginnerTechSkills);
        assigned = true;
       } else if (context.includes("engineer class")) {
        newClassSkills('engineer', beginnerEngineerSkills);
        assigned = true;
       }
     }
     // If no class detected, add all starter skills as default
     if (!assigned) {
      let allSkills = [
      ...(typeof beginnerMedicSkills !== "undefined" ? beginnerMedicSkills : []),
      ...beginnerTechSkills,
      ...beginnerEngineerSkills
     ];
     state.playerSkills.name = allSkills;
     state.playerSkills.lvl = allSkills.map(() => 1);
     state.playerSkills.cost = allSkills.map(() => 0); 
     storeSkillsToSC();
    }
  } 
}
//To STORE skill to sc
function storeSkillsToSC(){
  //Fetch skill sc
  const skillSC = storyCards.find(sc => sc.title === "Player Skills");

  //Format and display to sc Ex: Fireball 
  skillSC.entry = state.playerSkills.name.map((skill, index) => `${skill} (Lvl ${state.playerSkills.lvl[index]})`).join("\n");

  // Trim notes on char limit to prevent memory overfill
  if (skillSC.description.length > 3000) {
    halfIndex = Math.floor(skillSC.description.length / 2);
    skillSC.description = skillSC.description.slice(0, halfIndex);

    console.log("Trimming skillSC description to prevent memory overload.");
  }
}

//To RETRIEVE skills from SC.
//Put in output script so retreiving is not limited to on input.
function retrieveSkillsFromSC(){ 
  const skillSC = storyCards.find(sc => sc.title === "Player Skills");
  let temp = skillSC.entry;

  let skillHolder = [];
  let lvlHolder = [];
  let costHolder = [];
  // Match: SkillName (Lvl X)
  let matches = temp.matchAll(/(.+?)\s*\(Lvl\s*(\d+(?:\.\d+)?)\)/gi);

  for(const match of matches){
    skillHolder.push(match[1].trim());
    lvlHolder.push(Number(match[2]));
    costHolder.push(0); // No CP/MP cost for non-psyker skills
  }

  state.playerSkills.name = skillHolder;
  state.playerSkills.lvl = lvlHolder;
  state.playerSkills.cost = costHolder;
}

///Same but for Psyker Spells///

state.psykerSpells = state.psykerSpells || { name: [], lvl: [], cost: [] };

function createIfNoPsykerSpellSC() {
  if (!storyCards.find(sc => sc.title === "Psyker Spells")) {
    addStoryCard("Psyker Spells", "Blank", "Player Stats");
    const spellSC = storyCards.find(sc => sc.title === "Psyker Spells");
    spellSC.description = "Format: SpellName (Lvl X) (CP)";
    // Initialize with starter psyker spells
    state.psykerSpells = {
      name: [...beginnerPsykerSpells],
      lvl: beginnerPsykerSpells.map(() => 1),
      cost: beginnerPsykerSpells.map(() => 10)
    };
    storePsykerSpellsToSC();
  }
}

function storePsykerSpellsToSC() {
  const spellSC = storyCards.find(sc => sc.title === "Psyker Spells");
  spellSC.entry = state.psykerSpells.name.map((spell, i) =>
    `${spell} (Lvl ${state.psykerSpells.lvl[i]}) (${state.psykerSpells.cost[i]} CP)`
  ).join("\n");
}

function retrievePsykerSpellsFromSC() {
  const spellSC = storyCards.find(sc => sc.title === "Psyker Spells");
  let temp = spellSC.entry;
  let name = [], lvl = [], cost = [];
  let matches = temp.matchAll(/(.+?)\s*\(.*?(\d+(?:\.\d+)?).*?\)\s*\(.*?(\d+(?:\.\d+)?).*?\)/g);
  for (const match of matches) {
    name.push(match[1]);
    lvl.push(Number(match[2]));
    cost.push(Number(match[3]));
  }
  state.psykerSpells = { name, lvl, cost };
}
/////////////////////////////////////////////////////////////////////////////////////


// --- Passive Skill Trigger Function ---
function detectPassiveSkillTrigger(text) {
  const skillTypeEmotes = {
    tech: "🖥️",
    engineer: "🔧",
    medic: "🩺",
    psyker: "🧠"
  };

  function getSkillType(skill) {
    skill = skill.toLowerCase();
    if (beginnerTechSkills.map(s => s.toLowerCase()).includes(skill)) return "tech";
    if (beginnerEngineerSkills.map(s => s.toLowerCase()).includes(skill)) return "engineer";
    if (typeof beginnerMedicSkills !== "undefined" && beginnerMedicSkills.map(s => s.toLowerCase()).includes(skill)) return "medic";
    if (beginnerPsykerSpells.map(s => s.toLowerCase()).includes(skill)) return "psyker";
    return "";
  }

  let t = text.toLowerCase();

  for (let i = 0; i < state.playerSkills.name.length; i++) {
    let skill = state.playerSkills.name[i].toLowerCase();
    let cost = state.playerSkills.cost[i];
    if (cost > 0) continue; // Skip Psyker skills

    let triggers = skillTriggerMap[skill];
    if (!triggers) continue;

    for (let trig of triggers) {
      if (t.includes(trig)) {
        let oldLvl = state.playerSkills.lvl[i];
        let exp = randomFloat(0.2, 1.0);
        state.playerSkills.lvl[i] += exp;
        state.playerSkills.lvl[i] = Math.round(state.playerSkills.lvl[i] * 100) / 100;
        storeSkillsToSC();

        let skillType = getSkillType(state.playerSkills.name[i]);
        let emote = skillTypeEmotes[skillType] || "";
        text += ` ${emote} `;

        // Show skill instruction only once per turn
        if (!state.skillInstructionShown) {
        state.skillInstructionShown = true;
        log("state.skillInstructionShown set to true by detectPassiveSkillTrigger");
        }
        break;
      }
    }
  }
  return text;
}


///Corruption cost is reduced as skills level up.
function upgradePlayerSkills(text){
  // Only apply corruption cost reduction at milestones, no name change
  state.playerSkills.name.forEach((skill,index) => {
    [5,10,15,20,25].forEach(level => {
      if(Math.floor(state.playerSkills.lvl[index]) == level){
        // Level up skill to avoid another upgrade at this level
        state.playerSkills.lvl[index] = level + 1;
        // Corruption cost reduction
        state.playerSkills.cost[index] = Math.round(state.playerSkills.cost[index] * 0.95 * 100) / 100;
        // Optionally, notify the player
        text = text + ` Your ${state.playerSkills.name[index]} skill has been upgraded!`;
      }
    });
  });

  storeSkillsToSC();
  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

//Given an arr of words and an array of player storage (inv, spells, skills), check if anything from storage is mentioned in words arr and returns partialTF,full matchTF,storageindex
function checkPlayerStorage(text,wordsArr,playerStorage){
  hasThing = false;
  hasFullThing = false;
  finalThingIndex = false;
  ind = [];

  //Check if player has anything that PARTIALLY matches the input text
  //Loop through input words
  wordsArr.forEach((word, index1) => {
    //get the lower case version of the word
    loweredWord = word.toLowerCase();
    //loop through player things names
    playerStorage.forEach((thing, index2) => {
      // Get the lower case version of the thing name
      loweredThing = thing.toLowerCase();
      
      // Check if the word is long enough and if it matches part of the thing name
      if (loweredWord.length >= 4 && loweredThing.includes(loweredWord)) {
        hasThing = true;
        ind.push(index2);
      }
      //Else Check if the word matches the prefix of the thing name
      else if (loweredThing.startsWith(loweredWord) && loweredWord.length >= 3) {
          hasThing = true;
          ind.push(index2);
        }
      //Else Check if the word matches the suffix of the thing name
      else if (loweredThing.endsWith(loweredWord) && loweredWord.length >= 3) {
          hasThing = true;
          ind.push(index2);
        }

    });//end of thing loop
  });//end of input word loop
  log("hasThing: " + hasThing);

  //Continue if partial thing matched, which means storage has at least one thing that is mentioned in text
  if (ind.length > 0) {
    //From all thing matches, pick a random one to be the returned thing.
    finalThingIndex = ind[Math.floor(Math.random() * ind.length)];

    //Check for EXACT thing matches which overrides PARTIAL thing matches
    textLower = text.toLowerCase();

    //loop through player things
    playerStorage.forEach((thing, index) => {
      //Compare input text and player things for exact matches to override final index and flag full thing match.
      if (textLower.includes(thing.toLowerCase())) {
        finalThingIndex = index;
        hasFullThing = true;
      }
    })
    log("finalThingIndex: " + finalThingIndex);
  }

  return [hasThing,hasFullThing,finalThingIndex];
}

// --- New function for executing Psyker Spells ---
function executePsykerSpell(psykerIndex, fullPsykerMatch){
  // Add CP cost
  statUp("cp", state.psykerSpells.cost[psykerIndex] * 1);

  // Boost INTL
  statUp("intl", randomFloat(0.01,0.5));
  storeStatsToSC();

  // Skill power message logic (reuse your skillPowerRanges if desired)
  // Example:
  let spellLevel = state.psykerSpells.lvl[psykerIndex];
  const skillPowerRanges = [
    { min: 0, max: 10, msg: skillPower1 },
    { min: 10, max: 20, msg: skillPower2 },
    { min: 20, max: 30, msg: skillPower3 },
    { min: 30, max: 40, msg: skillPower4 },
    { min: 40, max: 50, msg: skillPower5 },
    { min: 50, max: 60, msg: skillPower6 },
    { min: 60, max: 70, msg: skillPower7 },
    { min: 70, max: 80, msg: skillPower8 },
    { min: 80, max: 90, msg: skillPower9 },
    { min: 90, max: Infinity, msg: skillPower10 }
  ];
  for (let range of skillPowerRanges) {
    if (spellLevel >= range.min && spellLevel < range.max) {
      postActionText = postActionText + " " + range.msg[randomInt(0, range.msg.length - 1)].replace("[Skill]", state.psykerSpells.name[psykerIndex]);
      break;
    }
  }

  // Save old level for logging
  let oldLvl = state.psykerSpells.lvl[psykerIndex];

  // Gain experience
  let spellExp = randomFloat(0, 0.8);
  log("spellExp: " + spellExp);

  state.psykerSpells.lvl[psykerIndex] += spellExp;
  state.psykerSpells.lvl[psykerIndex] = Math.round(state.psykerSpells.lvl[psykerIndex] * 100) / 100;

  // Save to story card
  storePsykerSpellsToSC();

  // Log to story card description
  const spellSC = storyCards.find(sc => sc.title === "Psyker Spells");
  spellSC.description = `Log ${state.turnCount} | ${state.psykerSpells.name[psykerIndex]} gained ${spellExp.toFixed(2)} lvl. Lvl ${oldLvl} => ${state.psykerSpells.lvl[psykerIndex]}\n` + spellSC.description;
}

//executes the skill if player has enough energy otherwise do nothing
function executeSkill(){
  //Must pass skill check
  if(skillCheck[0]){

      //If player has the EXACT skill
      if(fullSkillMatch == true){
    

        //Using skills boost stats
        statUp("intl", randomFloat(0.01,0.5));
        storeStatsToSC();
        
        // Define the ranges of skill effectiveness and the corresponding skill power messages
        const skillPowerRanges = [
          { min: 0, max: 10, msg: skillPower1 },
          { min: 10, max: 20, msg: skillPower2 },
          { min: 20, max: 30, msg: skillPower3 },
          { min: 30, max: 40, msg: skillPower4 },
          { min: 40, max: 50, msg: skillPower5 },
          { min: 50, max: 60, msg: skillPower6 },
          { min: 60, max: 70, msg: skillPower7 },
          { min: 70, max: 80, msg: skillPower8 },
          { min: 80, max: 90, msg: skillPower9 },
          { min: 90, max: Infinity, msg: skillPower10 }
        ];

        //Select msg based on skill level
        skillLevel = state.playerSkills.lvl[skillIndex];

        for (let range of skillPowerRanges) {
          if (skillLevel >= range.min && skillLevel < range.max) {
            postActionText = postActionText + " " + range.msg[randomInt(0, range.msg.length - 1)].replace("[Skill]", state.playerSkills.name[skillIndex]);
            break;
          }
        }
      }
      // If only PARTIAL skill matches, harness available skills
      else{ 
        // Psyker spells ADD to corruption (CP) even for partial matches
        statUp("cp", state.playerSkills.cost[skillIndex] * 1);

        // Using skills boost stats
        statUp("intl", randomFloat(0.01,0.5));
        storeStatsToSC();

        // Append skill harness text
        const randomIndex = randomInt(0, harnessSkill.length - 1);
        const skillText = harnessSkill[randomIndex].replace("[Skill]", state.playerSkills.name[skillIndex]);
        postActionText += ` ${skillText}`;

        postActionText = postActionText.replace(">","");
      }
      
      // Save current as old skill lvl for logging
      oldSkillLvl = state.playerSkills.lvl[skillIndex];

      // Gain experience in skills, which contributes to leveling them up
      skillExp = randomFloat(0, 0.8);
      log("skillExp: " + skillExp); 

      // Increase the skill's level by the generated experience
      state.playerSkills.lvl[skillIndex] += skillExp;

      // Round the skill level to two decimal places for accuracy and consistency
      state.playerSkills.lvl[skillIndex] = Math.round(state.playerSkills.lvl[skillIndex] * 100) / 100;

      // Save the updated skill data to the storage container
      storeSkillsToSC();

      //Log skill lvl change in skill sc notes
      const skillSC = storyCards.find(sc => sc.title === "Player Skills")   
      skillSC.description = `Log ${state.turnCount} | ${state.playerSkills.name[skillIndex]} gained ${skillExp.toFixed(2)} lvl. Lvl ${oldSkillLvl} => ${state.playerSkills.lvl[skillIndex]}\n` + skillSC.description;

    }
  }

// After skill checks, this function detects if the player is performing a heal action and executes the healing process. Defaults to skill healing if both talent and skill healing are available.
function detectTalentSkillHeal(){
  // Player must pass at least one of the skill checks to perform a healing action
  if(skillCheck[0]){
    healingSelf = false;

    //// Check if the player is performing a healing action. Use text b/c inp targetwords were simplified
    healing = cleanStringCheckForTargets(healingActions,text);
    log("healing: " + healing);

    // Check if the player is attempting to heal themselves
    healingSelf = cleanStringCheckForTargets(selfWords,text);
    log("healingSelf: " + healingSelf);

    // If both a healing action and self-healing are detected, proceed with healing based on skill level
    if(healing && healingSelf){
      getLvl = [];

      // If the player has a skill that passed the check, push its level into the getLvl array
      if(skillCheck[0]){
        getLvl.push(state.playerSkills.lvl[skillCheck[2]]);
      }
      log("getLvl: " + getLvl);
      
      // If only one skill or talent passed, the array will contain one level value.
      // Calculate healing amount based on the single level and heal the player.
      if(getLvl.length == 1){
        healAmt = getLvl[0] * 3;
        log('healAmt: '+ healAmt);
        statUp("hp",healAmt);
        postActionText = postActionText + " You feel better as you recover some health 🩺."
      }
      
    }


  }
}

//Main action function. Checks for "you + actions" that require items, or skills. Checks if player has something to fulfill it and executes it along with text result
function detectPlrActionsCallingStorage(text) {
    // Prevent action triggers during dialogue
    if (isPlayerDialoguing(text)) return text; // Skip action logic if dialoguing

    startAction = false;

    //If player is not dialoguing, check input for action words and split the input
    allActionWords = [...castWords,...healingActions];
    plrActionTextInput = [];
    plrActionTextInput = findTargetsThenSplit(text,allActionWords,plrActionTextInput,true);
    console.log("plrActionTextInput simplified: " + plrActionTextInput);

      //If input has action words get their indices
      if(plrActionTextInput != null){
        allActionWordIndices = [];
        allActionWordIndices = indicesOfTargets(plrActionTextInput,allActionWords);
        log("allActionWordIndices:" + allActionWordIndices);

        //Detect if there is  "you + actionword" or "and + actionword"
        if(allActionWordIndices != null){
          startAction = checkYouBeforeIndicesArr(plrActionTextInput,allActionWordIndices,3) || checkAndBeforeIndicesArr(plrActionTextInput,allActionWordIndices,2);
          log("startAction: " + startAction);
        }
      }
    

      if(startAction == true){
        // Initialize arrays [hasthing,hasfullthing,finalthingindex]
        itemCheck = [false,false,false];
        skillCheck = [false,false,false];
        psykerCheck = [false,false,false];
        postActionText = "";
        notEnoughText = "";

        //Check if player storage has thing used in input text available then returns [hasthing, hasfullthing, finalthingindex]
        itemCheck = checkPlayerStorage(text,plrActionTextInput,state.playerInv.item);
        log("itemCheck: " + itemCheck);


        // Check for regular skill
        skillCheck = checkPlayerStorage(text,plrActionTextInput,state.playerSkills.name);
        log("skillCheck: " + skillCheck);

        // Check for psyker spell
        psykerCheck = checkPlayerStorage(text,plrActionTextInput,state.psykerSpells.name);
        log("psykerCheck: " + psykerCheck);
        
        // Pipeline order is item>spell>skill
        // If player has the ITEM, get its success or fail text
        if(itemCheck[0]){
          hasAmt = false;
          fullItemMatch = itemCheck[1];
          itemIndex = itemCheck[2];
        }

        // --- PSYKER SPELL LOGIC ---
        if (psykerCheck[0]) {
        fullPsykerMatch = psykerCheck[1];
        psykerIndex = psykerCheck[2];

        // Always increase CP by spell cost, even for partial matches
        statUp("cp", state.psykerSpells.cost[psykerIndex] * 1);

        // Execute the spell
        executePsykerSpell(psykerIndex, fullPsykerMatch);




        // If player has the SKILL, check if they have enough cp, else make reject text
        if (skillCheck[0]) {
          fullSkillMatch = skillCheck[1];
          skillIndex = skillCheck[2];

          executeSkill();
        }

        // Checks for healing and executes it. Defaults to skill heal if both talent and skill work
        detectTalentSkillHeal();

        // Finalize action execution by appending text
        if(itemCheck[0]|| skillCheck[0]){
          text = text + postActionText;
          return text;
        }

        // If plr fails all checks, finalize action rejection
        if(!itemCheck[0] && !skillCheck[0]){
          // Failure Condition 1: plr passed a/all check but then failed all b/c no ep/cp/item amt
          if(notEnoughText.length > 0){
            text = text + notEnoughText;
            return text;
          }
          // Failure Condition 2: nonexistent in storage 
          else{ 
            text = text + ` ${realizePhrases[randomInt(0,realizePhrases.length-1)]} ${becauseYouPhrases[randomInt(0,becauseYouPhrases.length-1)]} ${assumedWrongPhrases[randomInt(0,assumedWrongPhrases.length-1)]}, ${slightlyWorseResults[randomInt(0,slightlyWorseResults.length-1)]}.`
            return text;
          }      
        }
      }

    }//end of start action

   return text;
  }

/////////////////////////////////////////////////////////////////////////////////////

//Check if player is first entering, then is entering into rest, and replenish their stats according to their rest intensity
function detectResting(text){
  startRest = false;
  isEntering = false;

  // Prevent resting actions during dialogue
  if (isPlayerDialoguing(text)) return text;

  // Check input for enter words and split the input
  restingTextInput = [];
  restingTextInput = findTargetsThenSplit(text, enterWords, restingTextInput, true);
  console.log("restingTextInput simplified: " + restingTextInput);


    //If input has enter words get their indices
    if(restingTextInput != null){
      allEnterWordsIndices = [];
      allEnterWordsIndices = indicesOfTargets(restingTextInput,enterWords);
      log("allEnterWordsIndices:" + allEnterWordsIndices);

      //Detect if there is  you + enter or and + enter
      if(allEnterWordsIndices != null){
        isEntering = checkYouBeforeIndicesArr(restingTextInput,allEnterWordsIndices,3) || checkAndBeforeIndicesArr(restingTextInput,allEnterWordsIndices,2);
        
        startRest = cleanStringCheckForTargets(restingWords,text);
        log("isEntering: "+ isEntering)
        log("startRest: " + startRest);
      }
    }

  if(isEntering && startRest){
    //Replenish stats based on player rest intensity
    lightRest = cleanStringCheckForTargets(lightRestWords,text);
    moderateRest = cleanStringCheckForTargets(moderateRestWords,text);
    fullRest = cleanStringCheckForTargets(fullRestWords,text);

    if(fullRest){
      statUp("hp", state.playerStats.maxHp * randomFloat(0.6,0.9));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.6,0.9));
      statUp("cp",state.playerStats.maxCp * randomFloat(-0.6,-0.9));
      text = text + " Your time resting leaves you feeling recovered."
    }
    else if(moderateRest){
      statUp("hp", state.playerStats.maxHp * randomFloat(0.4,0.6));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.4,0.6));
      statUp("cp",state.playerStats.maxCp * randomFloat(-0.4,-0.6));
      text = text + " Your time resting leaves you feeling better than you were before."

    }
    else if(lightRest){
      statUp("hp", state.playerStats.maxHp * randomFloat(0.2,0.4));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.2,0.4));
      statUp("cp",state.playerStats.maxCp * randomFloat(-0.2,-0.4));
      text = text + " Your time resting leaves you feeling a bit better."

    }
    else{
      statUp("hp", state.playerStats.maxHp * randomFloat(0.2,0.4));
      statUp("ep",state.playerStats.maxEp * randomFloat(0.2,0.4));
      statUp("cp",state.playerStats.maxCp * randomFloat(-0.2,-0.4));
      text = text + " Your time resting leaves you feeling more okay."

    }
    
    storeStatsToSC();
  }//end of startresting

  return text;
}

//Detects when player consumes something which heals them.
function detectConsuming(text){
  startConsume = false;

  // Prevent consuming actions during dialogue
  if (isPlayerDialoguing(text)) return text;

  // Check input for consume words and split the input
  consumingTextInput = [];
  consumingTextInput = findTargetsThenSplit(text, consumeWords, consumingTextInput, true);
  console.log("consumingTextInput simplified: " + consumingTextInput);


    //If input has consume words get their indices
    if(consumingTextInput != null){
      allConsumeWordsIndices = [];
      allConsumeWordsIndices = indicesOfTargets(consumingTextInput,consumeWords);
      log("allConsumeWordsIndices:" + allConsumeWordsIndices);

      //Detect if there is  you + consume or and + consume
      if(allConsumeWordsIndices != null){
        startConsume = checkYouBeforeIndicesArr(consumingTextInput,allConsumeWordsIndices,3) || checkAndBeforeIndicesArr(consumingTextInput,allConsumeWordsIndices,2);
        log("startConsume: " + startConsume);
      }
    }

  if(startConsume){
    //Verify intensity of player consumable
    lightHeal = cleanStringCheckForTargets(lightHealWords,text);
    moderateHeal = cleanStringCheckForTargets(moderateHealWords,text);
    strongHeal = cleanStringCheckForTargets(strongHealWords,text);
    greatHeal = cleanStringCheckForTargets(greatHealWords,text);
    powerfulHeal = cleanStringCheckForTargets(powerfulHealWords,text);
    log("healIntensity: " + [lightHeal,moderateHeal,strongHeal,greatHeal,powerfulHeal]);

    if(powerfulHeal){
      statUp("hp",100);
      statUp("ep",120);
      text = text + " You feel restored."
    }
    else if(greatHeal){
      statUp("hp",50);
      statUp("ep",80);
      text = text + " You feel greatly better."

    }
    else if(strongHeal){
      statUp("hp",30);
      statUp("ep",40);
      text = text + " You feel a lot better."

    }
    else if(moderateHeal){
      statUp("hp",20);
      statUp("ep",30);
      text = text + " You feel moderately better."

    } 
    else if(lightHeal){
      statUp("hp",10);
      statUp("ep",10);
      text = text + " You feel slightly better."
    }
    
    if(!lightHeal && !moderateHeal && !strongHeal && !greatHeal && !powerfulHeal){
      //default heal
      statUp("hp",5);
      statUp("ep",5)
      text = text + " You feel a bit better."
    }

    storeStatsToSC();
    return text

  }//end of startconsume

  return text;
}

// --- Consolidated Attack and Ranged Attack Logic ---

function getActionRepeatCount(text) {
  // Match "twice", "thrice", "x3", "3 times", etc.
  let match = text.match(/(\d+)\s*(?:times|x)?/i);
  if (match) {
    let count = parseInt(match[1]);
    if (!isNaN(count) && count > 0) return Math.min(count, 10);
  }
  // Handle "twice" and "thrice"
  if (/twice/i.test(text)) return 2;
  if (/thrice/i.test(text)) return 3;
  return 1;
}

function detectCombatAction(text, actionWords, actionType) {
  // --- Dialogue check ---
  if (isPlayerDialoguing(text)) return text;

  // --- Multi-action detection ---
  // Find all action word indices in the input
  let actionTextInput = findTargetsThenSplit(text, actionWords, [], true);
  // If no action words found, just return the text
  if (!actionTextInput) return text;

  let allActionWordIndices = indicesOfTargets(actionTextInput, actionWords);
  if (!allActionWordIndices) return text;

  // For each action word occurrence, check if it's in player context and process
  let resultText = text;
  let actionsTriggered = 0;
  for (let idx of allActionWordIndices) {
    // Check for "you" or "and" context before the action word
    let youContext = checkYouBeforeIndicesArr(actionTextInput, [idx], 3);
    let andContext = checkAndBeforeIndicesArr(actionTextInput, [idx], 2);
    if (youContext || andContext) {
      // For each action, determine repeat count (look for "twice", "three times", etc. after this action word)
      let phraseAfter = actionTextInput.slice(idx).join(' ');
      let repeatCount = getActionRepeatCount(phraseAfter);

      // Only check for equipped weapon if a ranged action is actually being attempted!
      if (actionType === 'ranged') {
        let weaponName = state.equippedWeapon || retrieveEquippedWeaponFromSC();
        if (!weaponName) {
          state.msgHolder += "You do not have a weapon equipped for ranged attacks.\n";
          resultText += " You fumble for a weapon, but nothing is equipped.";
          continue;
        }
        state.equippedWeapon = weaponName; // cache for this turn
        let weaponStats = retrieveWeaponFromSC(weaponName) || { cond: 100, ammo: 50, maxCond: 100, maxAmmo: 50, burstFireMode: false, overchargeMode: false };
        for (let i = 0; i < repeatCount; i++) {
          resultText = executeAction(resultText, actionType, weaponName, weaponStats);
          actionsTriggered++;
        }
      } else {
        for (let i = 0; i < repeatCount; i++) {
          resultText = executeAction(resultText, actionType);
          actionsTriggered++;
        }
      }
      if (repeatCount > 1) {
        resultText += ` (Action repeated ${repeatCount} times)`;
      }
    }
  }

  if (actionsTriggered > 0) return resultText;
  return text;
}

function executeAction(text, actionType, weaponName, weaponStats) {
  let stat, spd, statRanges, spdRanges, resourceCost, resourceCheck;
  if (actionType === 'attack') {
    stat = state.playerStats.atk;
    spd = state.playerStats.spd;
    statRanges = [
      { min: 0, max: 10, arr: attackTier1 },
      { min: 10, max: 20, arr: attackTier2 },
      { min: 20, max: 30, arr: attackTier3 },
      { min: 30, max: 40, arr: attackTier4 },
      { min: 40, max: 50, arr: attackTier5 },
      { min: 50, max: 60, arr: attackTier6 },
      { min: 60, max: 70, arr: attackTier7 },
      { min: 70, max: 80, arr: attackTier8 },
      { min: 80, max: 90, arr: attackTier9 },
      { min: 90, max: Infinity, arr: attackTier10 }
    ];
    spdRanges = [
      { min: 0, max: 10, arr: atkSpdTier1 },
      { min: 10, max: 20, arr: atkSpdTier2 },
      { min: 20, max: 30, arr: atkSpdTier3 },
      { min: 30, max: 40, arr: atkSpdTier4 },
      { min: 40, max: 50, arr: atkSpdTier5 },
      { min: 50, max: 60, arr: atkSpdTier6 },
      { min: 60, max: 70, arr: atkSpdTier7 },
      { min: 70, max: 80, arr: atkSpdTier8 },
      { min: 80, max: 90, arr: atkSpdTier9 },
      { min: 90, max: Infinity, arr: atkSpdTier10 }
    ];
    resourceCost = (stat > 100) ? (20 + stat / 25) * -1 : (2 * (stat / 10) + randomInt(0, 5)) * -1;
    resourceCheck = state.playerStats.ep >= Math.abs(resourceCost) && state.playerStats.ep >= 0;
    if (!resourceCheck) return text + ` You are too exhausted to attack.`;
  } else {
    stat = state.playerStats.ratk;
    spd = state.playerStats.spd;
    statRanges = [
      { min: 0, max: 10, arr: rangedattackTier1 },
      { min: 10, max: 20, arr: rangedattackTier2 },
      { min: 20, max: 30, arr: rangedattackTier3 },
      { min: 30, max: 40, arr: rangedattackTier4 },
      { min: 40, max: 50, arr: rangedattackTier5 },
      { min: 50, max: 60, arr: rangedattackTier6 },
      { min: 60, max: 70, arr: rangedattackTier7 },
      { min: 70, max: 80, arr: rangedattackTier8 },
      { min: 80, max: 90, arr: rangedattackTier9 },
      { min: 90, max: Infinity, arr: rangedattackTier10 }
    ];
    spdRanges = [
      { min: 0, max: 10, arr: ratkSpdTier1 },
      { min: 10, max: 20, arr: ratkSpdTier2 },
      { min: 20, max: 30, arr: ratkSpdTier3 },
      { min: 30, max: 40, arr: ratkSpdTier4 },
      { min: 40, max: 50, arr: ratkSpdTier5 },
      { min: 50, max: 60, arr: ratkSpdTier6 },
      { min: 60, max: 70, arr: ratkSpdTier7 },
      { min: 70, max: 80, arr: ratkSpdTier8 },
      { min: 80, max: 90, arr: ratkSpdTier9 },
      { min: 90, max: Infinity, arr: ratkSpdTier10 }
    ];
    // Ammo cost logic
     let ammoCost = weaponStats.burstFireMode ? -3 : -1;
    if (weaponStats.overchargeMode) ammoCost = -weaponStats.ammo;

    // Overcharge mode: cannot fire if ammo is below 50%
    if (
  weaponStats.overchargeMode &&
  (weaponStats.ammo < Math.ceil(weaponStats.maxAmmo * 0.5))
) {
  return text + ` You need at least 50% ammunition to overcharge your weapon!`;
}

    resourceCost = ammoCost;
    resourceCheck = weaponStats.ammo >= Math.abs(ammoCost) && weaponStats.ammo > 0;
    if (!resourceCheck) return text + ` *Click* your weapon is out of ammunition.`;
}

  let luckyHit = false;
  let luckRoll = randomInt(1, 100);
  if (luckRoll <= state.playerStats.lck && luckRoll >= 1) {
    luckyHit = true;
    statUp("lck", randomFloat(0.01, 1));
    
    // Add lucky message FIRST 
    text += ` ${sensePhrases[randomInt(0, sensePhrases.length - 1)]} ${luckyPhrases[randomInt(0, luckyPhrases.length - 1)]}.`;
  }

  // Speed message
  for (let range of spdRanges) {
    if (spd >= range.min && spd < range.max) {
      text += ` ${range.arr[randomInt(0, range.arr.length - 1)]}`;
      statUp("spd", randomFloat(0.01, 1));
      break;
    }
  }

  // Attack/ranged message
  for (let range of statRanges) {
    if (stat >= range.min && stat < range.max) {
      text += ` and ${range.arr[randomInt(0, range.arr.length - 1)].toLowerCase()}`;
      statUp(actionType === 'attack' ? "atk" : "ratk", randomFloat(0.01, 1));
      break;
    }
  }

  // Resource cost
   if (actionType === 'attack') {
    statUp("ep", resourceCost);
  } else {
    weaponStats.ammo += resourceCost;
    if (weaponStats.ammo < 0) weaponStats.ammo = 0;
    updateWeaponModes(weaponName, weaponStats);
    storeWeaponToSC(weaponName, weaponStats); // Pass the updated stats!
    log("Ammo after deduction: " + weaponStats.ammo);
  }

  storeStatsToSC();
  return text;
}

/////////////////////////////////////////////////////////////////////////////////////

// Function to check if the output contains any "hurt" words or patterns, and if so, apply damage to the player's stats
function testHurt(hurtType, severity, text) {
  for (const pattern of hurtType) {
    const match = pattern.exec(text);
    if (match) {
      // Check for negation (e.g., "not wounded", "avoided injury")
      const negationRegex = /\b(no|not|never|avoid|avoided|dodged|missed|without)\b/i;
      const before = text.slice(Math.max(0, match.index - 20), match.index);
      if (negationRegex.test(before)) continue;

      //Check if the match is about the player ---
      // Get up to 10 words before the match
      const wordsBefore = text.slice(Math.max(0, match.index - 40), match.index).toLowerCase();
      // Only log if "you", "your", or "yourself" is within 10 words before the match
      if (!/\b(you|your|yourself|yours|myself|i|me|mine)\b/.test(wordsBefore)) continue;

      // Check that the match is not about "the wounded [enemy]"
      const after = text.slice(match.index, match.index + 30).toLowerCase();
      if (/\b(mutant|heretic|enemy|cultist|npc|soldier|guard|beast|creature|monster|target|foe|opponent|adversary|villain|criminal|bandit|raider|robot|android|alien|xenos|daemon|demon|zombie|ghoul|husk|corpse|body)\b/.test(after)) continue;

      // Try to find a relevant body part in the text near the match
let bodyPart = null;
const windowStart = Math.max(0, match.index - 60);
const windowEnd = Math.min(text.length, match.index + 60);
const contextWindow = text.slice(windowStart, windowEnd).toLowerCase();

for (const part of bodyParts) {
  // Look for singular and plural forms
  const partRegex = new RegExp(`\\b${part}\\b|\\b${part}s\\b`, "i");
  if (partRegex.test(contextWindow)) {
    bodyPart = part;
    break;
  }
}
if (!bodyPart) {
  // Fallback: use "body" if nothing found
  bodyPart = "body";
}
const description = match[0];
storeInjuryToSC(severity, bodyPart, description);
state.msgHolder += `Injury: ${severity} injury to your ${bodyPart} (${description})\n`;
      break; // Only log one injury per severity per call
    }
  }
}

// Function to check output if player got damaged and applies hp dmg to stats
function detectHurt(text) {
  testHurt(severeHurtWords, "Severe", text);
  testHurt(greatHurtWords, "Great", text);
  testHurt(strongHurtWords, "Strong", text);
  testHurt(moderateHurtWords, "Moderate", text);
  testHurt(lightHurtWords, "Light", text);
  return text;
}

// Resets game over state to allows player to continue story
function resetGameOverState() {
  state.gameOver = false;
  state.msgHolder = "";
  // Optionally reset other game over flags or stats here
  log("Game over state has been reset.");
}

////////////////////////////////////////Helper Functions/////////////////////////////////////////////

// Helper function to check if player is dialoguing
function isPlayerDialoguing(text) {
  let textLower = text.toLowerCase();
  return dialoguePhrases.some(phrase => textLower.includes(phrase.toLowerCase()));
}

// Helper function for debugging non-item matches
function debugNonItemMatch(itemName) {
  const lowerItem = itemName.toLowerCase();
  if (nonItemRegex.test(lowerItem)) {
    // List of all patterns to check individually
    const patterns = [
      "cover( behind)?", "in cover", "take cover", "shelters?", "barriers?", "corners?", 
      "walls?", "floors?", "grounds?", "ceilings?", "windows?", "doors?", "hallways?", 
      "corridors?", "rooms?", "crates?", "tables?", "chairs?", "beds?", "barricades?", 
      "pillars?", "platforms?", "ledges?", "alcoves?", "nooks?", "hides?", "hiding spots?", 
      "spots?", "locations?", "areas?", "places?", "positions?", 
      "stances?( behind| in| at)?", "take aim", "aim", "surroundings?"
    ];
    
    // Find which specific pattern caused the match
    for (const pattern of patterns) {
      const regex = new RegExp(`\\b${pattern}\\b`, 'i');
      if (regex.test(lowerItem)) {
        console.log(`🚫 Item "${itemName}" was filtered out by nonItemRegex pattern: "${pattern}"`);
        return true;
      }
    }
    console.log(`🚫 Item "${itemName}" was filtered out by nonItemRegex but specific pattern not identified`);
    return true;
  }
  return false;
}
